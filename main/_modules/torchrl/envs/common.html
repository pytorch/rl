


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>torchrl.envs.common &mdash; torchrl main documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sphinx-design.5ea377869091fd0449014c60fc090103.min.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','UA-117752657-2');</script>
    <!-- End Google Tag Manager -->
  

  
  <script src="../../../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Learn
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/get-started">
                  <span class=dropdown-title>Get Started</span>
                  <p>Run PyTorch locally or get started quickly with one of the supported cloud platforms</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials">
                  <span class="dropdown-title">Tutorials</span>
                  <p>Whats new in PyTorch tutorials</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/beginner/basics/intro.html">
                  <span class="dropdown-title">Learn the Basics</span>
                  <p>Familiarize yourself with PyTorch concepts and modules</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/recipes/recipes_index.html">
                  <span class="dropdown-title">PyTorch Recipes</span>
                  <p>Bite-size, ready-to-deploy PyTorch code examples</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/beginner/introyt.html">
                  <span class="dropdown-title">Intro to PyTorch - YouTube Series</span>
                  <p>Master PyTorch basics with our engaging YouTube tutorial series</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Ecosystem
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/ecosystem">
                  <span class="dropdown-title">Tools</span>
                  <p>Learn about the tools and frameworks in the PyTorch Ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/#community-module">
                  <span class=dropdown-title>Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="https://discuss.pytorch.org/" target="_blank">
                  <span class=dropdown-title>Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/resources">
                  <span class=dropdown-title>Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/ecosystem/contributor-awards-2024">
                  <span class="dropdown-title">Contributor Awards - 2024</span>
                  <p>Award winners announced at this year's PyTorch Conference</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Edge
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/edge">
                  <span class="dropdown-title">About PyTorch Edge</span>
                  <p>Build innovative and privacy-aware AI experiences for edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/executorch-overview">
                  <span class="dropdown-title">ExecuTorch</span>
                  <p>End-to-end solution for enabling on-device inference capabilities across mobile and edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/executorch/stable/index.html">
                  <span class="dropdown-title">ExecuTorch Docs</span>
                </a>
              </div>
            </div>  
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/docs/stable/index.html">
                  <span class="dropdown-title">PyTorch</span>
                  <p>Explore the documentation for comprehensive guidance on how to use PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/pytorch-domains">
                  <span class="dropdown-title">PyTorch Domains</span>
                  <p>Read the PyTorch Domains documentation to learn more about domain-specific libraries</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Blogs & News 
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/blog/">
                  <span class="dropdown-title">PyTorch Blog</span>
                  <p>Catch up on the latest technical news and happenings</p>
                </a>
                 <a class="nav-dropdown-item" href="https://pytorch.org/community-blog">
                  <span class="dropdown-title">Community Blog</span>
                  <p>Stories from the PyTorch ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/videos">
                  <span class="dropdown-title">Videos</span>
                  <p>Learn about the latest PyTorch tutorials, new, and more </p>
                <a class="nav-dropdown-item" href="https://pytorch.org/community-stories">
                  <span class="dropdown-title">Community Stories</span>
                  <p>Learn how our community solves real, everyday machine learning problems with PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/events">
                  <span class="dropdown-title">Events</span>
                  <p>Find events, webinars, and podcasts</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/newsletter">
                  <span class="dropdown-title">Newsletter</span>
                  <p>Stay up-to-date with the latest updates</p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                About
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/foundation">
                  <span class="dropdown-title">PyTorch Foundation</span>
                  <p>Learn more about the PyTorch Foundation</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/governing-board">
                  <span class="dropdown-title">Governing Board</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/credits">
                  <span class="dropdown-title">Cloud Credit Program</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tac">
                  <span class="dropdown-title">Technical Advisory Council</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/staff">
                  <span class="dropdown-title">Staff</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/contact-us">
                  <span class="dropdown-title">Contact Us</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div class="no-dropdown">
              <a href="https://pytorch.org/join" data-cta="join">
                Become a Member
              </a>
            </div>
          </li>
          <li>
           <div class="main-menu-item">
             <a href="https://github.com/pytorch/pytorch" class="github-icon">
             </a>
           </div>
          </li>
          <!--- TODO: This block adds the search icon to the nav bar. We will enable it later. 
          <li>
            <div class="main-menu-item">
             <a href="https://github.com/pytorch/pytorch" class="search-icon">
             </a>
            </div>
          </li>
          --->
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            
    <div class="version">
      <a href="../../../../versions.html"><span style="font-size:110%">main (0.7.0+6e40548) &#x25BC</span></a>
    </div>
    


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          </div>

          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/getting-started-0.html">Get started with Environments, TED and transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/getting-started-1.html">Get started with TorchRLâ€™s modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/getting-started-2.html">Getting started with model optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/getting-started-3.html">Get started with data collection and storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/getting-started-4.html">Get started with logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/getting-started-5.html">Get started with your own first training loop</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/coding_ppo.html">Reinforcement Learning (PPO) with TorchRL Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/pendulum.html">Pendulum: Writing your environment and transforms with TorchRL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/torchrl_demo.html">Introduction to TorchRL</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/multiagent_ppo.html">Multi-Agent Reinforcement Learning (PPO) with TorchRL Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/torchrl_envs.html">TorchRL envs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/pretrained_models.html">Using pretrained models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/dqn_with_rnn.html">Recurrent DQN: Training recurrent policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/rb_tutorial.html">Using Replay Buffers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/export.html">Exporting TorchRL modules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/multiagent_competitive_ddpg.html">Competitive Multi-Agent Reinforcement Learning (DDPG) with TorchRL Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/multi_task.html">Task-specific policy in multi-task environments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/coding_ddpg.html">TorchRL objectives: Coding a DDPG loss</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/coding_dqn.html">TorchRL trainer: A DQN example</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">API Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/knowledge_base.html">Knowledge Base</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../../../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="../../index.html">Module code</a> &gt;</li>
        
      <li>torchrl.envs.common</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        
    
    
          <!-- Google Tag Manager (noscript) -->
          <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=UA-117752657-2"
          height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
          <!-- End Google Tag Manager (noscript) -->
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <h1>Source code for torchrl.envs.common</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Meta Platforms, Inc. and affiliates.</span>
<span class="c1">#</span>
<span class="c1"># This source code is licensed under the MIT license found in the</span>
<span class="c1"># LICENSE file in the root directory of this source tree.</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.nn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tensordict</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">is_tensor_collection</span><span class="p">,</span>
    <span class="n">LazyStackedTensorDict</span><span class="p">,</span>
    <span class="n">TensorDictBase</span><span class="p">,</span>
    <span class="n">unravel_key</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tensordict.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">_is_leaf_nontensor</span><span class="p">,</span> <span class="n">NO_DEFAULT</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tensordict.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_non_tensor</span><span class="p">,</span> <span class="n">NestedKey</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchrl._utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_ends_with</span><span class="p">,</span>
    <span class="n">_make_ordinal_device</span><span class="p">,</span>
    <span class="n">_replace_last</span><span class="p">,</span>
    <span class="n">implement_for</span><span class="p">,</span>
    <span class="n">prod</span><span class="p">,</span>
    <span class="n">seed_generator</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.data.tensor_specs</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Categorical</span><span class="p">,</span>
    <span class="n">Composite</span><span class="p">,</span>
    <span class="n">NonTensor</span><span class="p">,</span>
    <span class="n">TensorSpec</span><span class="p">,</span>
    <span class="n">Unbounded</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.data.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">DEVICE_TYPING</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_make_compatible_policy</span><span class="p">,</span>
    <span class="n">_repr_by_depth</span><span class="p">,</span>
    <span class="n">_StepMDP</span><span class="p">,</span>
    <span class="n">_terminated_or_truncated</span><span class="p">,</span>
    <span class="n">_update_during_reset</span><span class="p">,</span>
    <span class="n">check_env_specs</span> <span class="k">as</span> <span class="n">check_env_specs_func</span><span class="p">,</span>
    <span class="n">get_available_libraries</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">LIBRARIES</span> <span class="o">=</span> <span class="n">get_available_libraries</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_tensor_to_np</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>


<span class="n">dtype_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_maybe_unlock</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">is_locked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_locked</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_cache&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_cache_value</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Caches the result of the decorated function in env._cache dictionary.&quot;&quot;&quot;</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_locked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;_cache&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">NO_DEFAULT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">NO_DEFAULT</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;_cache&quot;</span><span class="p">,</span> <span class="p">{})[</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_clear_cache_when_set</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A decorator for EnvBase methods that should clear the caches when called.&quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># if there&#39;s no cache we&#39;ll just recompute the value</span>
        <span class="k">if</span> <span class="s2">&quot;_cache&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<div class="viewcode-block" id="EnvMetaData"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvMetaData.html#torchrl.envs.EnvMetaData">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">EnvMetaData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for environment meta-data storage and passing in multiprocessed settings.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">,</span>
        <span class="n">specs</span><span class="p">:</span> <span class="n">Composite</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">,</span>
        <span class="n">env_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="n">batch_locked</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">device_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensordict</span> <span class="o">=</span> <span class="n">tensordict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">specs</span> <span class="o">=</span> <span class="n">specs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env_str</span> <span class="o">=</span> <span class="n">env_str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span> <span class="o">=</span> <span class="n">batch_locked</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device_map</span> <span class="o">=</span> <span class="n">device_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_dynamic_specs</span> <span class="o">=</span> <span class="n">_has_dynamic_specs</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tensordict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
        <span class="n">td</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensordict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">td</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">td</span><span class="o">.</span><span class="n">clear_device_</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">td</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">td</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">specs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="nd">@tensordict</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tensordict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tensordict</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

    <span class="nd">@specs</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">specs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_specs</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata_from_env</span><span class="p">(</span><span class="n">env</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnvMetaData</span><span class="p">:</span>
        <span class="n">tensordict</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fake_tensordict</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">done_key</span> <span class="ow">in</span> <span class="n">env</span><span class="o">.</span><span class="n">done_keys</span><span class="p">:</span>
            <span class="n">tensordict</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="n">_replace_last</span><span class="p">(</span><span class="n">done_key</span><span class="p">,</span> <span class="s2">&quot;_reset&quot;</span><span class="p">),</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">tensordict</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">done_key</span><span class="p">))),</span>
            <span class="p">)</span>

        <span class="n">specs</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">specs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="n">env_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">device</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
        <span class="n">batch_locked</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">batch_locked</span>
        <span class="c1"># we need to save the device map, as the tensordict will be placed on cpu</span>
        <span class="n">device_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">fill_device_map</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">device_map</span><span class="o">=</span><span class="n">device_map</span><span class="p">):</span>
            <span class="n">device_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">device</span>

        <span class="n">tensordict</span><span class="o">.</span><span class="n">named_apply</span><span class="p">(</span><span class="n">fill_device_map</span><span class="p">,</span> <span class="n">nested_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EnvMetaData</span><span class="p">(</span>
            <span class="n">tensordict</span><span class="o">=</span><span class="n">tensordict</span><span class="p">,</span>
            <span class="n">specs</span><span class="o">=</span><span class="n">specs</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">env_str</span><span class="o">=</span><span class="n">env_str</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">batch_locked</span><span class="o">=</span><span class="n">batch_locked</span><span class="p">,</span>
            <span class="n">device_map</span><span class="o">=</span><span class="n">device_map</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnvMetaData</span><span class="p">:</span>
        <span class="n">tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensordict</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">EnvMetaData</span><span class="p">(</span>
            <span class="n">tensordict</span><span class="o">=</span><span class="n">tensordict</span><span class="p">,</span>
            <span class="n">specs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="p">),</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">env_str</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env_str</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="n">batch_locked</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span><span class="p">,</span>
            <span class="n">device_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device_map</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">EnvMetaData</span><span class="p">(</span>
            <span class="n">tensordict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tensordict</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span>
            <span class="n">specs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">]),</span>
            <span class="n">env_str</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">env_str</span><span class="p">),</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="n">batch_locked</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span><span class="p">,</span>
            <span class="n">device_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device_map</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">DEVICE_TYPING</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnvMetaData</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">_make_ordinal_device</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
            <span class="n">device_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">device</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">device_map</span><span class="p">}</span>
        <span class="n">tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensordict</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EnvMetaData</span><span class="p">(</span>
            <span class="n">tensordict</span><span class="o">=</span><span class="n">tensordict</span><span class="p">,</span>
            <span class="n">specs</span><span class="o">=</span><span class="n">specs</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">env_str</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env_str</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">batch_locked</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span><span class="p">,</span>
            <span class="n">device_map</span><span class="o">=</span><span class="n">device_map</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">tensordict.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_getitem_batch_size</span>

        <span class="k">return</span> <span class="n">EnvMetaData</span><span class="p">(</span>
            <span class="n">tensordict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tensordict</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
            <span class="n">specs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">_getitem_batch_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">item</span><span class="p">),</span>
            <span class="n">env_str</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env_str</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="n">batch_locked</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span><span class="p">,</span>
            <span class="n">device_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device_map</span><span class="p">,</span>
        <span class="p">)</span></div>


<span class="k">class</span><span class="w"> </span><span class="nc">_EnvPostInit</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">spec_locked</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;spec_locked&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">auto_reset</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;auto_reset&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">auto_reset_replace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;auto_reset_replace&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">instance</span><span class="p">:</span> <span class="n">EnvBase</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;_cache&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">spec_locked</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">input_spec</span><span class="o">.</span><span class="n">lock_</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">lock_</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_is_spec_locked</span> <span class="o">=</span> <span class="n">spec_locked</span>

        <span class="c1"># we create the done spec by adding a done/terminated entry if one is missing</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_create_done_specs</span><span class="p">()</span>
        <span class="c1"># we access lazy attributed to make sure they&#39;re built properly.</span>
        <span class="c1"># This isn&#39;t done in `__init__` because we don&#39;t know if super().__init__</span>
        <span class="c1"># will be called before or after the specs, batch size etc are set.</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">done_spec</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">reward_keys</span>
        <span class="c1"># _ = instance.action_keys</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">state_spec</span>
        <span class="k">if</span> <span class="n">auto_reset</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.transforms.transforms</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
                <span class="n">AutoResetEnv</span><span class="p">,</span>
                <span class="n">AutoResetTransform</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">AutoResetEnv</span><span class="p">(</span>
                <span class="n">instance</span><span class="p">,</span> <span class="n">AutoResetTransform</span><span class="p">(</span><span class="n">replace</span><span class="o">=</span><span class="n">auto_reset_replace</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">done_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">full_done_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">obs_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">full_observation_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">reward_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">full_reward_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="c1"># state_keys can match obs_keys so we don&#39;t test that</span>
        <span class="n">action_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">full_action_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">state_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">full_state_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">total_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">keyset</span> <span class="ow">in</span> <span class="p">(</span><span class="n">done_keys</span><span class="p">,</span> <span class="n">obs_keys</span><span class="p">,</span> <span class="n">reward_keys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">total_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">keyset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The set of keys of one spec collides (culprit: </span><span class="si">{</span><span class="n">total_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">keyset</span><span class="p">)</span><span class="si">}</span><span class="s2">) with another.&quot;</span>
                <span class="p">)</span>
            <span class="n">total_set</span> <span class="o">=</span> <span class="n">total_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">keyset</span><span class="p">)</span>
        <span class="n">total_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">keyset</span> <span class="ow">in</span> <span class="p">(</span><span class="n">state_keys</span><span class="p">,</span> <span class="n">action_keys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">total_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">keyset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The set of keys of one spec collides (culprit: </span><span class="si">{</span><span class="n">total_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">keyset</span><span class="p">)</span><span class="si">}</span><span class="s2">) with another.&quot;</span>
                <span class="p">)</span>
            <span class="n">total_set</span> <span class="o">=</span> <span class="n">total_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">keyset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instance</span>


<div class="viewcode-block" id="EnvBase"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">EnvBase</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_EnvPostInit</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract environment parent class.</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        device (torch.device): The device of the environment. Deviceless environments</span>
<span class="sd">            are allowed (device=None). If not ``None``, all specs will be cast</span>
<span class="sd">            on that device and it is expected that all inputs and outputs will</span>
<span class="sd">            live on that device.</span>
<span class="sd">            Defaults to ``None``.</span>
<span class="sd">        batch_size (torch.Size or equivalent, optional): batch-size of the environment.</span>
<span class="sd">            Corresponds to the leading dimension of all the input and output</span>
<span class="sd">            tensordicts the environment reads and writes. Defaults to an empty batch-size.</span>
<span class="sd">        run_type_checks (bool, optional): If ``True``, type-checks will occur</span>
<span class="sd">            at every reset and every step. Defaults to ``False``.</span>
<span class="sd">        allow_done_after_reset (bool, optional): if ``True``, an environment can</span>
<span class="sd">            be done after a call to :meth:`reset` is made. Defaults to ``False``.</span>
<span class="sd">        spec_locked (bool, optional): if ``True``, the specs are locked and can only be</span>
<span class="sd">            modified if :meth:`~torchrl.envs.EnvBase.set_spec_lock_` is called.</span>

<span class="sd">            .. note:: The locking is achieved by the `EnvBase` metaclass. It does not appear in the</span>
<span class="sd">                `__init__` method and is included in the keyword arguments strictly for type-hinting purpose.</span>

<span class="sd">            .. seealso:: :ref:`Locking environment specs &lt;Environment-lock&gt;`.</span>

<span class="sd">            Defaults to ``True``.</span>
<span class="sd">        auto_reset (bool, optional): if ``True``, the env is assumed to reset automatically</span>
<span class="sd">            when done. Defaults to ``False``.</span>

<span class="sd">            .. note:: The auto-resetting is achieved by the `EnvBase` metaclass. It does not appear in the</span>
<span class="sd">                `__init__` method and is included in the keyword arguments strictly for type-hinting purpose.</span>

<span class="sd">            .. seealso:: The :ref:`auto-resetting environments API &lt;autoresetting_envs&gt;` section in the API</span>
<span class="sd">                documentation.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        done_spec (Composite): equivalent to ``full_done_spec`` as all</span>
<span class="sd">            ``done_specs`` contain at least a ``&quot;done&quot;`` and a ``&quot;terminated&quot;`` entry</span>
<span class="sd">        action_spec (TensorSpec): the spec of the action. Links to the spec of the leaf</span>
<span class="sd">            action if only one action tensor is to be expected. Otherwise links to</span>
<span class="sd">            ``full_action_spec``.</span>
<span class="sd">        observation_spec (Composite): equivalent to ``full_observation_spec``.</span>
<span class="sd">        reward_spec (TensorSpec): the spec of the reward. Links to the spec of the leaf</span>
<span class="sd">            reward if only one reward tensor is to be expected. Otherwise links to</span>
<span class="sd">            ``full_reward_spec``.</span>
<span class="sd">        state_spec (Composite): equivalent to ``full_state_spec``.</span>
<span class="sd">        full_done_spec (Composite): a composite spec such that ``full_done_spec.zero()``</span>
<span class="sd">            returns a tensordict containing only the leaves encoding the done status of the</span>
<span class="sd">            environment.</span>
<span class="sd">        full_action_spec (Composite): a composite spec such that ``full_action_spec.zero()``</span>
<span class="sd">            returns a tensordict containing only the leaves encoding the action of the</span>
<span class="sd">            environment.</span>
<span class="sd">        full_observation_spec (Composite): a composite spec such that ``full_observation_spec.zero()``</span>
<span class="sd">            returns a tensordict containing only the leaves encoding the observation of the</span>
<span class="sd">            environment.</span>
<span class="sd">        full_reward_spec (Composite): a composite spec such that ``full_reward_spec.zero()``</span>
<span class="sd">            returns a tensordict containing only the leaves encoding the reward of the</span>
<span class="sd">            environment.</span>
<span class="sd">        full_state_spec (Composite): a composite spec such that ``full_state_spec.zero()``</span>
<span class="sd">            returns a tensordict containing only the leaves encoding the inputs (actions</span>
<span class="sd">            excluded) of the environment.</span>
<span class="sd">        batch_size (torch.Size): The batch-size of the environment.</span>
<span class="sd">        device (torch.device): the device where the input/outputs of the environment</span>
<span class="sd">            are to be expected. Can be ``None``.</span>
<span class="sd">        is_spec_locked (bool): returns ``True`` if the specs are locked. See the :attr:`spec_locked`</span>
<span class="sd">            argument above.</span>

<span class="sd">    Methods:</span>
<span class="sd">        step (TensorDictBase -&gt; TensorDictBase): step in the environment</span>
<span class="sd">        reset (TensorDictBase, optional -&gt; TensorDictBase): reset the environment</span>
<span class="sd">        set_seed (int -&gt; int): sets the seed of the environment</span>
<span class="sd">        rand_step (TensorDictBase, optional -&gt; TensorDictBase): random step given the action spec</span>
<span class="sd">        rollout (Callable, ... -&gt; TensorDictBase): executes a rollout in the environment with the given policy (or random</span>
<span class="sd">            steps if no policy is provided)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from torchrl.envs import EnvBase</span>
<span class="sd">        &gt;&gt;&gt; class CounterEnv(EnvBase):</span>
<span class="sd">        ...     def __init__(self, batch_size=(), device=None, **kwargs):</span>
<span class="sd">        ...         self.observation_spec = Composite(</span>
<span class="sd">        ...             count=Unbounded(batch_size, device=device, dtype=torch.int64))</span>
<span class="sd">        ...         self.action_spec = Unbounded(batch_size, device=device, dtype=torch.int8)</span>
<span class="sd">        ...         # done spec and reward spec are set automatically</span>
<span class="sd">        ...     def _step(self, tensordict):</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; from torchrl.envs.libs.gym import GymEnv</span>
<span class="sd">        &gt;&gt;&gt; env = GymEnv(&quot;Pendulum-v1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; env.batch_size  # how many envs are run at once</span>
<span class="sd">        torch.Size([])</span>
<span class="sd">        &gt;&gt;&gt; env.input_spec</span>
<span class="sd">        Composite(</span>
<span class="sd">            full_state_spec: None,</span>
<span class="sd">            full_action_spec: Composite(</span>
<span class="sd">                action: BoundedContinuous(</span>
<span class="sd">                    shape=torch.Size([1]),</span>
<span class="sd">                    space=ContinuousBox(</span>
<span class="sd">                        low=Tensor(shape=torch.Size([1]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                        high=Tensor(shape=torch.Size([1]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                    device=cpu,</span>
<span class="sd">                    dtype=torch.float32,</span>
<span class="sd">                    domain=continuous), device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([]))</span>
<span class="sd">        &gt;&gt;&gt; env.action_spec</span>
<span class="sd">        BoundedContinuous(</span>
<span class="sd">            shape=torch.Size([1]),</span>
<span class="sd">            space=ContinuousBox(</span>
<span class="sd">                low=Tensor(shape=torch.Size([1]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                high=Tensor(shape=torch.Size([1]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">            device=cpu,</span>
<span class="sd">            dtype=torch.float32,</span>
<span class="sd">            domain=continuous)</span>
<span class="sd">        &gt;&gt;&gt; env.observation_spec</span>
<span class="sd">        Composite(</span>
<span class="sd">            observation: BoundedContinuous(</span>
<span class="sd">                shape=torch.Size([3]),</span>
<span class="sd">                space=ContinuousBox(</span>
<span class="sd">                    low=Tensor(shape=torch.Size([3]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                    high=Tensor(shape=torch.Size([3]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                dtype=torch.float32,</span>
<span class="sd">                domain=continuous), device=cpu, shape=torch.Size([]))</span>
<span class="sd">        &gt;&gt;&gt; env.reward_spec</span>
<span class="sd">        UnboundedContinuous(</span>
<span class="sd">            shape=torch.Size([1]),</span>
<span class="sd">            space=None,</span>
<span class="sd">            device=cpu,</span>
<span class="sd">            dtype=torch.float32,</span>
<span class="sd">            domain=continuous)</span>
<span class="sd">        &gt;&gt;&gt; env.done_spec</span>
<span class="sd">        Categorical(</span>
<span class="sd">            shape=torch.Size([1]),</span>
<span class="sd">            space=DiscreteBox(n=2),</span>
<span class="sd">            device=cpu,</span>
<span class="sd">            dtype=torch.bool,</span>
<span class="sd">            domain=discrete)</span>
<span class="sd">        &gt;&gt;&gt; # the output_spec contains all the expected outputs</span>
<span class="sd">        &gt;&gt;&gt; env.output_spec</span>
<span class="sd">        Composite(</span>
<span class="sd">            full_reward_spec: Composite(</span>
<span class="sd">                reward: UnboundedContinuous(</span>
<span class="sd">                    shape=torch.Size([1]),</span>
<span class="sd">                    space=None,</span>
<span class="sd">                    device=cpu,</span>
<span class="sd">                    dtype=torch.float32,</span>
<span class="sd">                    domain=continuous), device=cpu, shape=torch.Size([])),</span>
<span class="sd">            full_observation_spec: Composite(</span>
<span class="sd">                observation: BoundedContinuous(</span>
<span class="sd">                    shape=torch.Size([3]),</span>
<span class="sd">                    space=ContinuousBox(</span>
<span class="sd">                        low=Tensor(shape=torch.Size([3]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                        high=Tensor(shape=torch.Size([3]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                    device=cpu,</span>
<span class="sd">                    dtype=torch.float32,</span>
<span class="sd">                    domain=continuous), device=cpu, shape=torch.Size([])),</span>
<span class="sd">            full_done_spec: Composite(</span>
<span class="sd">                done: Categorical(</span>
<span class="sd">                    shape=torch.Size([1]),</span>
<span class="sd">                    space=DiscreteBox(n=2),</span>
<span class="sd">                    device=cpu,</span>
<span class="sd">                    dtype=torch.bool,</span>
<span class="sd">                    domain=discrete), device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([]))</span>

<span class="sd">    .. note:: Learn more about dynamic specs and environments :ref:`here &lt;dynamic_envs&gt;`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_batch_size</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">_device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">_is_spec_locked</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">DEVICE_TYPING</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">run_type_checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_done_after_reset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">spec_locked</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">auto_reset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;_cache&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;_batch_size&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;_device&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we want an error to be raised if we pass batch_size but</span>
            <span class="c1"># it&#39;s already been set</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">(())</span>

        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_device&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_make_ordinal_device</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">output_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_output_spec&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_output_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_spec</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="n">device</span> <span class="ow">and</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_output_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_output_spec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>
        <span class="n">input_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_input_spec&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_input_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_spec</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="n">device</span> <span class="ow">and</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_input_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_input_spec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="n">output_spec</span><span class="o">.</span><span class="n">unlock_</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">input_spec</span><span class="o">.</span><span class="n">unlock_</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;full_observation_spec&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_spec</span><span class="p">:</span>
            <span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_observation_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;full_done_spec&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_spec</span><span class="p">:</span>
            <span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;full_reward_spec&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_spec</span><span class="p">:</span>
            <span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_reward_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;full_state_spec&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_spec</span><span class="p">:</span>
            <span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_state_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;full_action_spec&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_spec</span><span class="p">:</span>
            <span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_action_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;is_closed&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_type_checks</span> <span class="o">=</span> <span class="n">run_type_checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allow_done_after_reset</span> <span class="o">=</span> <span class="n">allow_done_after_reset</span>

<div class="viewcode-block" id="EnvBase.set_spec_lock_"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.set_spec_lock_">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_spec_lock_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnvBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Locks or unlocks the environment&#39;s specs.</span>

<span class="sd">        Args:</span>
<span class="sd">            mode (bool): Whether to lock (`True`) or unlock (`False`) the specs. Defaults to `True`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            EnvBase: The environment instance itself.</span>

<span class="sd">        .. seealso:: :ref:`Locking environment specs &lt;Environment-lock&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_output_spec&quot;</span><span class="p">)</span>
        <span class="n">input_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_input_spec&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">output_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_spec</span><span class="o">.</span><span class="n">lock_</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">input_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">input_spec</span><span class="o">.</span><span class="n">lock_</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">output_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_spec</span><span class="o">.</span><span class="n">unlock_</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">input_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">input_spec</span><span class="o">.</span><span class="n">unlock_</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_is_spec_locked&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_spec_locked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets whether the environment&#39;s specs are locked.</span>

<span class="sd">        This property can be modified directly.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the specs are locked, False otherwise.</span>

<span class="sd">        .. seealso:: :ref:`Locking environment specs &lt;Environment-lock&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_is_spec_locked&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="nd">@is_spec_locked</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_spec_locked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="EnvBase.auto_specs_"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.auto_specs_">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">auto_specs_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">policy</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TensorDictBase</span><span class="p">],</span> <span class="n">TensorDictBase</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">action_key</span><span class="p">:</span> <span class="n">NestedKey</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;action&quot;</span><span class="p">,</span>
        <span class="n">done_key</span><span class="p">:</span> <span class="n">NestedKey</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">observation_key</span><span class="p">:</span> <span class="n">NestedKey</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;observation&quot;</span><span class="p">,</span>
        <span class="n">reward_key</span><span class="p">:</span> <span class="n">NestedKey</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;reward&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Automatically sets the specifications (specs) of the environment based on a random rollout using a given policy.</span>

<span class="sd">        This method performs a rollout using the provided policy to infer the input and output specifications of the environment.</span>
<span class="sd">        It updates the environment&#39;s specs for actions, observations, rewards, and done signals based on the data collected</span>
<span class="sd">        during the rollout.</span>

<span class="sd">        Args:</span>
<span class="sd">            policy (Callable[[TensorDictBase], TensorDictBase]):</span>
<span class="sd">                A callable policy that takes a `TensorDictBase` as input and returns a `TensorDictBase` as output.</span>
<span class="sd">                This policy is used to perform the rollout and determine the specs.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            tensordict (TensorDictBase, optional):</span>
<span class="sd">                An optional `TensorDictBase` instance to be used as the initial state for the rollout.</span>
<span class="sd">                If not provided, the environment&#39;s `reset` method will be called to obtain the initial state.</span>
<span class="sd">            action_key (NestedKey or List[NestedKey], optional):</span>
<span class="sd">                The key(s) used to identify actions in the `TensorDictBase`. Defaults to &quot;action&quot;.</span>
<span class="sd">            done_key (NestedKey or List[NestedKey], optional):</span>
<span class="sd">                The key(s) used to identify done signals in the `TensorDictBase`. Defaults to ``None``, which will</span>
<span class="sd">                attempt to use [&quot;done&quot;, &quot;terminated&quot;, &quot;truncated&quot;] as potential keys.</span>
<span class="sd">            observation_key (NestedKey or List[NestedKey], optional):</span>
<span class="sd">                The key(s) used to identify observations in the `TensorDictBase`. Defaults to &quot;observation&quot;.</span>
<span class="sd">            reward_key (NestedKey or List[NestedKey], optional):</span>
<span class="sd">                The key(s) used to identify rewards in the `TensorDictBase`. Defaults to &quot;reward&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            EnvBase: The environment instance with updated specs.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If there are keys in the output specs that are not accounted for in the provided keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span> <span class="ow">or</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="k">if</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># Input specs</span>
        <span class="n">tensordict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">policy</span><span class="p">(</span><span class="n">tensordict</span><span class="p">))</span>
        <span class="n">step_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">tensordict</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">tensordict2</span> <span class="o">=</span> <span class="n">step_0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">step_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">policy</span><span class="p">(</span><span class="n">tensordict2</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">nexts_0</span><span class="p">:</span> <span class="n">TensorDictBase</span> <span class="o">=</span> <span class="n">step_0</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">)</span>
        <span class="n">nexts_1</span><span class="p">:</span> <span class="n">TensorDictBase</span> <span class="o">=</span> <span class="n">step_1</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">)</span>

        <span class="n">input_spec_stack</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tensordict</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">_tensor_to_spec</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="n">input_spec_stack</span><span class="p">),</span>
            <span class="n">tensordict2</span><span class="p">,</span>
            <span class="n">named</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">nested_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">is_leaf</span><span class="o">=</span><span class="n">_is_leaf_nontensor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">input_spec</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span><span class="n">input_spec_stack</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span> <span class="ow">and</span> <span class="n">batch_size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">input_spec</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">input_spec</span> <span class="o">=</span> <span class="n">input_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">action_key</span><span class="p">,</span> <span class="n">NestedKey</span><span class="p">):</span>
            <span class="n">action_key</span> <span class="o">=</span> <span class="p">[</span><span class="n">action_key</span><span class="p">]</span>
        <span class="n">full_action_spec</span> <span class="o">=</span> <span class="n">input_spec</span><span class="o">.</span><span class="n">separates</span><span class="p">(</span><span class="o">*</span><span class="n">action_key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Output specs</span>

        <span class="n">output_spec_stack</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nexts_0</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">_tensor_to_spec</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="n">output_spec_stack</span><span class="p">),</span>
            <span class="n">nexts_1</span><span class="p">,</span>
            <span class="n">named</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">nested_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">is_leaf</span><span class="o">=</span><span class="n">_is_leaf_nontensor</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">output_spec</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span><span class="n">output_spec_stack</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span> <span class="ow">and</span> <span class="n">batch_size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">output_spec</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">output_spec</span> <span class="o">=</span> <span class="n">output_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">done_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">done_key</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;done&quot;</span><span class="p">,</span> <span class="s2">&quot;terminated&quot;</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">]</span>
        <span class="n">full_done_spec</span> <span class="o">=</span> <span class="n">output_spec</span><span class="o">.</span><span class="n">separates</span><span class="p">(</span><span class="o">*</span><span class="n">done_key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full_done_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span> <span class="o">=</span> <span class="n">full_done_spec</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reward_key</span><span class="p">,</span> <span class="n">NestedKey</span><span class="p">):</span>
            <span class="n">reward_key</span> <span class="o">=</span> <span class="p">[</span><span class="n">reward_key</span><span class="p">]</span>
        <span class="n">full_reward_spec</span> <span class="o">=</span> <span class="n">output_spec</span><span class="o">.</span><span class="n">separates</span><span class="p">(</span><span class="o">*</span><span class="n">reward_key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">observation_key</span><span class="p">,</span> <span class="n">NestedKey</span><span class="p">):</span>
            <span class="n">observation_key</span> <span class="o">=</span> <span class="p">[</span><span class="n">observation_key</span><span class="p">]</span>
        <span class="n">full_observation_spec</span> <span class="o">=</span> <span class="n">output_spec</span><span class="o">.</span><span class="n">separates</span><span class="p">(</span><span class="o">*</span><span class="n">observation_key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output_spec</span><span class="o">.</span><span class="n">is_empty</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Keys </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">output_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span><span class="w"> </span><span class="kc">True</span><span class="p">))</span><span class="si">}</span><span class="s2"> are unaccounted for. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Make sure you have passed all the leaf names to the auto_specs_ method.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">full_action_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_action_spec</span> <span class="o">=</span> <span class="n">full_action_spec</span>
        <span class="k">if</span> <span class="n">full_done_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span> <span class="o">=</span> <span class="n">full_done_spec</span>
        <span class="k">if</span> <span class="n">full_observation_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_observation_spec</span> <span class="o">=</span> <span class="n">full_observation_spec</span>
        <span class="k">if</span> <span class="n">full_reward_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_reward_spec</span> <span class="o">=</span> <span class="n">full_reward_spec</span>
        <span class="n">full_state_spec</span> <span class="o">=</span> <span class="n">input_spec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_state_spec</span> <span class="o">=</span> <span class="n">full_state_spec</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">check_env_specs_func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_env_specs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;return_contiguous&quot;</span><span class="p">,</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_dynamic_specs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">check_env_specs_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">check_env_specs</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">check_env_specs_func</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="EnvBase.cardinality"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.cardinality">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The cardinality of the action space.</span>

<span class="sd">        By default, this is just a wrapper around :meth:`env.action_space.cardinality &lt;~torchrl.data.TensorSpec.cardinality&gt;`.</span>

<span class="sd">        This class is useful when the action spec is variable:</span>

<span class="sd">        - The number of actions can be undefined, e.g., ``Categorical(n=-1)``;</span>
<span class="sd">        - The action cardinality may depend on the action mask;</span>
<span class="sd">        - The shape can be dynamic, as in ``Unbound(shape=(-1))``.</span>

<span class="sd">        In these cases, the :meth:`cardinality` should be overwritten,</span>

<span class="sd">        Args:</span>
<span class="sd">            tensordict (TensorDictBase, optional): a tensordict containing the data required to compute the cardinality.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_action_spec</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">_inplace_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_batch_locked</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># inplace update will write tensors in-place on the provided tensordict.</span>
        <span class="c1"># This is risky, especially if gradients need to be passed (in-place copy</span>
        <span class="c1"># for tensors that are part of computational graphs will result in an error).</span>
        <span class="c1"># It can also lead to inconsistencies when calling rollout.</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_inplace_update</span> <span class="o">=</span> <span class="n">_inplace_update</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_batch_locked</span> <span class="o">=</span> <span class="n">_batch_locked</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># cached in_keys to be excluded from update when calling step</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_cache_in_keys</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># We may assign _input_spec to the cls, but it must be assigned to the instance</span>
        <span class="c1"># we pull it off, and place it back where it belongs</span>
        <span class="n">_input_spec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_input_spec&quot;</span><span class="p">):</span>
            <span class="n">_input_spec</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_input_spec</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_input_spec&quot;</span><span class="p">)</span>
        <span class="n">_output_spec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_output_spec&quot;</span><span class="p">):</span>
            <span class="n">_output_spec</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_output_spec</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_output_spec&quot;</span><span class="p">)</span>
        <span class="n">env</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_input_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">env</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_input_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_input_spec</span>
        <span class="k">if</span> <span class="n">_output_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">env</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_output_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_output_spec</span>
        <span class="k">return</span> <span class="n">env</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">&quot;_input_spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_observation_spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_action_spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_reward_spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_output_spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_state_spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_done_spec&quot;</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;To set an environment spec, please use `env.observation_spec = obs_spec` (without the leading&quot;</span>
                <span class="s2">&quot; underscore).&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">batch_locked</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the environment can be used with a batch size different from the one it was initialized with or not.</span>

<span class="sd">        If True, the env needs to be used with a tensordict having the same batch size as the env.</span>
<span class="sd">        batch_locked is an immutable property.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batch_locked</span>

    <span class="nd">@batch_locked</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">batch_locked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;batch_locked is a read-only property&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run_type_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_type_checks</span>

    <span class="nd">@run_type_checks</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run_type_checks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_type_checks</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_type_checks</span> <span class="o">=</span> <span class="n">run_type_checks</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">batch_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of envs batched in this environment instance organised in a `torch.Size()` object.</span>

<span class="sd">        Environment may be similar or different but it is assumed that they have little if</span>
<span class="sd">        not no interactions between them (e.g., multi-task or batched execution</span>
<span class="sd">        in parallel).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_batch_size&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_batch_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([])</span>
        <span class="k">return</span> <span class="n">_batch_size</span>

    <span class="nd">@batch_size</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">batch_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_batch_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;output_spec&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">value</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;input_spec&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Equivalent to :attr:`~.batch_size`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_device&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">device</span>

    <span class="nd">@device</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_device&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_device&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;device cannot be set. Call env.to(device) instead.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ndimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndimension</span><span class="p">()</span>

<div class="viewcode-block" id="EnvBase.append_transform"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.append_transform">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">append_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Transform</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TensorDictBase</span><span class="p">],</span> <span class="n">TensorDictBase</span><span class="p">],</span>  <span class="c1"># noqa: F821</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnvBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a transformed environment where the callable/transform passed is applied.</span>

<span class="sd">        Args:</span>
<span class="sd">            transform (Transform or Callable[[TensorDictBase], TensorDictBase]): the transform to apply</span>
<span class="sd">                to the environment.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import GymEnv</span>
<span class="sd">            &gt;&gt;&gt; import torch</span>
<span class="sd">            &gt;&gt;&gt; env = GymEnv(&quot;CartPole-v1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; loc = 0.5</span>
<span class="sd">            &gt;&gt;&gt; scale = 1.0</span>
<span class="sd">            &gt;&gt;&gt; transform = lambda data: data.set(&quot;observation&quot;, (data.get(&quot;observation&quot;) - loc)/scale)</span>
<span class="sd">            &gt;&gt;&gt; env = env.append_transform(transform=transform)</span>
<span class="sd">            &gt;&gt;&gt; print(env)</span>
<span class="sd">            TransformedEnv(</span>
<span class="sd">                env=GymEnv(env=CartPole-v1, batch_size=torch.Size([]), device=cpu),</span>
<span class="sd">                transform=_CallableTransform(keys=[]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.transforms.transforms</span><span class="w"> </span><span class="kn">import</span> <span class="n">TransformedEnv</span>

        <span class="k">return</span> <span class="n">TransformedEnv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span></div>

    <span class="c1"># Parent specs: input and output spec.</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorSpec</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Input spec.</span>

<span class="sd">        The composite spec containing all specs for data input to the environments.</span>

<span class="sd">        It contains:</span>

<span class="sd">        - &quot;full_action_spec&quot;: the spec of the input actions</span>
<span class="sd">        - &quot;full_state_spec&quot;: the spec of all other environment inputs</span>

<span class="sd">        This attribute is locked and should be read-only.</span>
<span class="sd">        Instead, to set the specs contained in it, use the respective properties.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs.libs.gym import GymEnv</span>
<span class="sd">            &gt;&gt;&gt; env = GymEnv(&quot;Pendulum-v1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; env.input_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                full_state_spec: None,</span>
<span class="sd">                full_action_spec: Composite(</span>
<span class="sd">                    action: BoundedContinuous(</span>
<span class="sd">                        shape=torch.Size([1]),</span>
<span class="sd">                        space=ContinuousBox(</span>
<span class="sd">                            low=Tensor(shape=torch.Size([1]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                            high=Tensor(shape=torch.Size([1]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.float32,</span>
<span class="sd">                        domain=continuous), device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([]))</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_input_spec&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">is_locked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_locked</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">input_spec</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span>
                <span class="n">full_state_spec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_input_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_spec</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">input_spec</span>

    <span class="nd">@input_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">TensorSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;input_spec is protected.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorSpec</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Output spec.</span>

<span class="sd">        The composite spec containing all specs for data output from the environments.</span>

<span class="sd">        It contains:</span>

<span class="sd">        - &quot;full_reward_spec&quot;: the spec of reward</span>
<span class="sd">        - &quot;full_done_spec&quot;: the spec of done</span>
<span class="sd">        - &quot;full_observation_spec&quot;: the spec of all other environment outputs</span>

<span class="sd">        This attribute is locked and should be read-only.</span>
<span class="sd">        Instead, to set the specs contained in it, use the respective properties.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs.libs.gym import GymEnv</span>
<span class="sd">            &gt;&gt;&gt; env = GymEnv(&quot;Pendulum-v1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; env.output_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                full_reward_spec: Composite(</span>
<span class="sd">                    reward: UnboundedContinuous(</span>
<span class="sd">                        shape=torch.Size([1]),</span>
<span class="sd">                        space=None,</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.float32,</span>
<span class="sd">                        domain=continuous), device=cpu, shape=torch.Size([])),</span>
<span class="sd">                full_observation_spec: Composite(</span>
<span class="sd">                    observation: BoundedContinuous(</span>
<span class="sd">                        shape=torch.Size([3]),</span>
<span class="sd">                        space=ContinuousBox(</span>
<span class="sd">                            low=Tensor(shape=torch.Size([3]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                            high=Tensor(shape=torch.Size([3]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.float32,</span>
<span class="sd">                        domain=continuous), device=cpu, shape=torch.Size([])),</span>
<span class="sd">                full_done_spec: Composite(</span>
<span class="sd">                    done: Categorical(</span>
<span class="sd">                        shape=torch.Size([1]),</span>
<span class="sd">                        space=DiscreteBox(n=2),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.bool,</span>
<span class="sd">                        domain=discrete), device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([]))</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_output_spec&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">is_locked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_locked</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">output_spec</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_output_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_spec</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_spec</span>

    <span class="nd">@output_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">TensorSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;output_spec is protected.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_cache_value</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">action_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The action keys of an environment.</span>

<span class="sd">        By default, there will only be one key named &quot;action&quot;.</span>

<span class="sd">        Keys are sorted by depth in the data tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_action_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_repr_by_depth</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">keys</span>

    <span class="nd">@property</span>
    <span class="nd">@_cache_value</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">state_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The state keys of an environment.</span>

<span class="sd">        By default, there will only be one key named &quot;state&quot;.</span>

<span class="sd">        Keys are sorted by depth in the data tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_state_keys&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">state_keys</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_state_spec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_repr_by_depth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_state_keys&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys</span>
        <span class="k">return</span> <span class="n">keys</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">action_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NestedKey</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The action key of an environment.</span>

<span class="sd">        By default, this will be &quot;action&quot;.</span>

<span class="sd">        If there is more than one action key in the environment, this function will raise an exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">action_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;action_key requested but more than one key present in the environment&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">action_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Action spec: action specs belong to input_spec</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">action_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorSpec</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The ``action`` spec.</span>

<span class="sd">        The ``action_spec`` is always stored as a composite spec.</span>

<span class="sd">        If the action spec is provided as a simple spec, this will be returned.</span>

<span class="sd">            &gt;&gt;&gt; env.action_spec = Unbounded(1)</span>
<span class="sd">            &gt;&gt;&gt; env.action_spec</span>
<span class="sd">            UnboundedContinuous(</span>
<span class="sd">                shape=torch.Size([1]),</span>
<span class="sd">                space=ContinuousBox(</span>
<span class="sd">                    low=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                    high=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                dtype=torch.float32,</span>
<span class="sd">                domain=continuous)</span>

<span class="sd">        If the action spec is provided as a composite spec and contains only one leaf,</span>
<span class="sd">        this function will return just the leaf.</span>

<span class="sd">            &gt;&gt;&gt; env.action_spec = Composite({&quot;nested&quot;: {&quot;action&quot;: Unbounded(1)}})</span>
<span class="sd">            &gt;&gt;&gt; env.action_spec</span>
<span class="sd">            UnboundedContinuous(</span>
<span class="sd">                shape=torch.Size([1]),</span>
<span class="sd">                space=ContinuousBox(</span>
<span class="sd">                    low=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                    high=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                dtype=torch.float32,</span>
<span class="sd">                domain=continuous)</span>

<span class="sd">        If the action spec is provided as a composite spec and has more than one leaf,</span>
<span class="sd">        this function will return the whole spec.</span>

<span class="sd">            &gt;&gt;&gt; env.action_spec = Composite({&quot;nested&quot;: {&quot;action&quot;: Unbounded(1), &quot;another_action&quot;: Categorical(1)}})</span>
<span class="sd">            &gt;&gt;&gt; env.action_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                nested: Composite(</span>
<span class="sd">                    action: UnboundedContinuous(</span>
<span class="sd">                        shape=torch.Size([1]),</span>
<span class="sd">                        space=ContinuousBox(</span>
<span class="sd">                            low=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                            high=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.float32,</span>
<span class="sd">                        domain=continuous),</span>
<span class="sd">                    another_action: Categorical(</span>
<span class="sd">                        shape=torch.Size([]),</span>
<span class="sd">                        space=DiscreteBox(n=1),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.int64,</span>
<span class="sd">                        domain=discrete), device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([]))</span>

<span class="sd">        To retrieve the full spec passed, use:</span>

<span class="sd">            &gt;&gt;&gt; env.input_spec[&quot;full_action_spec&quot;]</span>

<span class="sd">        This property is mutable.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs.libs.gym import GymEnv</span>
<span class="sd">            &gt;&gt;&gt; env = GymEnv(&quot;Pendulum-v1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; env.action_spec</span>
<span class="sd">            BoundedContinuous(</span>
<span class="sd">                shape=torch.Size([1]),</span>
<span class="sd">                space=ContinuousBox(</span>
<span class="sd">                    low=Tensor(shape=torch.Size([1]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                    high=Tensor(shape=torch.Size([1]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                dtype=torch.float32,</span>
<span class="sd">                domain=continuous)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">action_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_action_spec&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Failed to find the action_spec.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">action_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">action_spec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">action_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">action_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;action&quot;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;You are querying a non-trivial, single action_spec, i.e., there is only &quot;</span>
                    <span class="s2">&quot;one action known by the environment but it is not named `&#39;action&#39;`. &quot;</span>
                    <span class="s2">&quot;Currently, env.action_spec returns the leaf but for consistency with the &quot;</span>
                    <span class="s2">&quot;setter, this will return the full spec instead (from v0.8 and on).&quot;</span><span class="p">,</span>
                    <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">action_spec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">action_key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># the key may have changed</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="s2">&quot;The action_key attribute seems to have changed. &quot;</span>
                    <span class="s2">&quot;This occurs when a action_spec is updated without &quot;</span>
                    <span class="s2">&quot;calling `env.action_spec = new_spec`. &quot;</span>
                    <span class="s2">&quot;Make sure you rely on this  type of command &quot;</span>
                    <span class="s2">&quot;to set the action and other specs.&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@action_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">action_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">TensorSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="o">.</span><span class="n">_device</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;action_spec of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> do not have a shape attribute.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The value of spec.shape (</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) must match the env batch size (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;Please use `env.action_spec_unbatched = value` to set unbatched versions instead.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Composite</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span>
                <span class="n">action</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_action_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_action_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The full action spec.</span>

<span class="sd">        ``full_action_spec`` is a :class:`~torchrl.data.Composite`` instance</span>
<span class="sd">        that contains all the action entries.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import BraxEnv</span>
<span class="sd">            &gt;&gt;&gt; for envname in BraxEnv.available_envs:</span>
<span class="sd">            ...     break</span>
<span class="sd">            &gt;&gt;&gt; env = BraxEnv(envname)</span>
<span class="sd">            &gt;&gt;&gt; env.full_action_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                action: BoundedContinuous(</span>
<span class="sd">                    shape=torch.Size([8]),</span>
<span class="sd">                    space=ContinuousBox(</span>
<span class="sd">                        low=Tensor(shape=torch.Size([8]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                        high=Tensor(shape=torch.Size([8]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                    device=cpu,</span>
<span class="sd">                    dtype=torch.float32,</span>
<span class="sd">                    domain=continuous), device=cpu, shape=torch.Size([]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">full_action_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;full_action_spec&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full_action_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">is_locked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_locked</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">full_action_spec</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_action_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_action_spec</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">full_action_spec</span>

    <span class="nd">@full_action_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_action_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">action_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="c1"># Reward spec</span>
    <span class="nd">@property</span>
    <span class="nd">@_cache_value</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reward_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The reward keys of an environment.</span>

<span class="sd">        By default, there will only be one key named &quot;reward&quot;.</span>

<span class="sd">        Keys are sorted by depth in the data tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reward_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_reward_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">_repr_by_depth</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reward_keys</span>

    <span class="nd">@property</span>
    <span class="nd">@_cache_value</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observation_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The observation keys of an environment.</span>

<span class="sd">        By default, there will only be one key named &quot;observation&quot;.</span>

<span class="sd">        Keys are sorted by depth in the data tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">observation_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_observation_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">_repr_by_depth</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">observation_keys</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reward_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The reward key of an environment.</span>

<span class="sd">        By default, this will be &quot;reward&quot;.</span>

<span class="sd">        If there is more than one reward key in the environment, this function will raise an exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reward_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;reward_key requested but more than one key present in the environment&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Reward spec: reward specs belong to output_spec</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reward_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorSpec</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The ``reward`` spec.</span>

<span class="sd">        The ``reward_spec`` is always stored as a composite spec.</span>

<span class="sd">        If the reward spec is provided as a simple spec, this will be returned.</span>

<span class="sd">            &gt;&gt;&gt; env.reward_spec = Unbounded(1)</span>
<span class="sd">            &gt;&gt;&gt; env.reward_spec</span>
<span class="sd">            UnboundedContinuous(</span>
<span class="sd">                shape=torch.Size([1]),</span>
<span class="sd">                space=ContinuousBox(</span>
<span class="sd">                    low=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                    high=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                dtype=torch.float32,</span>
<span class="sd">                domain=continuous)</span>

<span class="sd">        If the reward spec is provided as a composite spec and contains only one leaf,</span>
<span class="sd">        this function will return just the leaf.</span>

<span class="sd">            &gt;&gt;&gt; env.reward_spec = Composite({&quot;nested&quot;: {&quot;reward&quot;: Unbounded(1)}})</span>
<span class="sd">            &gt;&gt;&gt; env.reward_spec</span>
<span class="sd">            UnboundedContinuous(</span>
<span class="sd">                shape=torch.Size([1]),</span>
<span class="sd">                space=ContinuousBox(</span>
<span class="sd">                    low=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                    high=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                dtype=torch.float32,</span>
<span class="sd">                domain=continuous)</span>

<span class="sd">        If the reward spec is provided as a composite spec and has more than one leaf,</span>
<span class="sd">        this function will return the whole spec.</span>

<span class="sd">            &gt;&gt;&gt; env.reward_spec = Composite({&quot;nested&quot;: {&quot;reward&quot;: Unbounded(1), &quot;another_reward&quot;: Categorical(1)}})</span>
<span class="sd">            &gt;&gt;&gt; env.reward_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                nested: Composite(</span>
<span class="sd">                    reward: UnboundedContinuous(</span>
<span class="sd">                        shape=torch.Size([1]),</span>
<span class="sd">                        space=ContinuousBox(</span>
<span class="sd">                            low=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                            high=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.float32,</span>
<span class="sd">                        domain=continuous),</span>
<span class="sd">                    another_reward: Categorical(</span>
<span class="sd">                        shape=torch.Size([]),</span>
<span class="sd">                        space=DiscreteBox(n=1),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.int64,</span>
<span class="sd">                        domain=discrete), device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([]))</span>

<span class="sd">        To retrieve the full spec passed, use:</span>

<span class="sd">            &gt;&gt;&gt; env.output_spec[&quot;full_reward_spec&quot;]</span>

<span class="sd">        This property is mutable.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs.libs.gym import GymEnv</span>
<span class="sd">            &gt;&gt;&gt; env = GymEnv(&quot;Pendulum-v1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; env.reward_spec</span>
<span class="sd">            UnboundedContinuous(</span>
<span class="sd">                shape=torch.Size([1]),</span>
<span class="sd">                space=None,</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                dtype=torch.float32,</span>
<span class="sd">                domain=continuous)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">reward_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_reward_spec&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="c1"># populate the &quot;reward&quot; entry</span>
            <span class="c1"># this will be raised if there is not full_reward_spec (unlikely) or no reward_key</span>
            <span class="c1"># Since output_spec is lazily populated with an empty composite spec for</span>
            <span class="c1"># reward_spec, the second case is much more likely to occur.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reward_spec</span> <span class="o">=</span> <span class="n">Unbounded</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">reward_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_reward_spec&quot;</span><span class="p">]</span>

        <span class="n">reward_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward_keys</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reward_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">reward_keys</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reward_spec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reward_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;reward&quot;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;You are querying a non-trivial, single reward_spec, i.e., there is only &quot;</span>
                    <span class="s2">&quot;one reward known by the environment but it is not named `&#39;reward&#39;`. &quot;</span>
                    <span class="s2">&quot;Currently, env.reward_spec returns the leaf but for consistency with the &quot;</span>
                    <span class="s2">&quot;setter, this will return the full spec instead (from v0.8 and on).&quot;</span><span class="p">,</span>
                    <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">reward_spec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reward_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="nd">@reward_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reward_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">TensorSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">_device</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;reward_spec of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> do not have a shape &quot;</span> <span class="sa">f</span><span class="s2">&quot;attribute.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The value of spec.shape (</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) must match the env batch size (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;Please use `env.reward_spec_unbatched = value` to set unbatched versions instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Composite</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span>
                <span class="n">reward</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;the reward_spec&#39;s leaves shape cannot be empty (this error&quot;</span>
                    <span class="s2">&quot; usually comes from trying to set a reward_spec&quot;</span>
                    <span class="s2">&quot; with a null number of dimensions. Try using a multidimensional&quot;</span>
                    <span class="s2">&quot; spec instead, for instance with a singleton dimension at the tail).&quot;</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_reward_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_reward_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The full reward spec.</span>

<span class="sd">        ``full_reward_spec`` is a :class:`~torchrl.data.Composite`` instance</span>
<span class="sd">        that contains all the reward entries.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import gymnasium</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import GymWrapper, TransformedEnv, RenameTransform</span>
<span class="sd">            &gt;&gt;&gt; base_env = GymWrapper(gymnasium.make(&quot;Pendulum-v1&quot;))</span>
<span class="sd">            &gt;&gt;&gt; env = TransformedEnv(base_env, RenameTransform(&quot;reward&quot;, (&quot;nested&quot;, &quot;reward&quot;)))</span>
<span class="sd">            &gt;&gt;&gt; env.full_reward_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                nested: Composite(</span>
<span class="sd">                    reward: UnboundedContinuous(</span>
<span class="sd">                        shape=torch.Size([1]),</span>
<span class="sd">                        space=ContinuousBox(</span>
<span class="sd">                            low=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                            high=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.float32,</span>
<span class="sd">                        domain=continuous), device=None, shape=torch.Size([])), device=cpu, shape=torch.Size([]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_reward_spec&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># populate the &quot;reward&quot; entry</span>
            <span class="c1"># this will be raised if there is not full_reward_spec (unlikely) or no reward_key</span>
            <span class="c1"># Since output_spec is lazily populated with an empty composite spec for</span>
            <span class="c1"># reward_spec, the second case is much more likely to occur.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reward_spec</span> <span class="o">=</span> <span class="n">Unbounded</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_reward_spec&quot;</span><span class="p">]</span>

    <span class="nd">@full_reward_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_reward_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reward_spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">spec</span>

    <span class="c1"># done spec</span>
    <span class="nd">@property</span>
    <span class="nd">@_cache_value</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The done keys of an environment.</span>

<span class="sd">        By default, there will only be one key named &quot;done&quot;.</span>

<span class="sd">        Keys are sorted by depth in the data tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">done_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">_repr_by_depth</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">done_keys</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The done key of an environment.</span>

<span class="sd">        By default, this will be &quot;done&quot;.</span>

<span class="sd">        If there is more than one done key in the environment, this function will raise an exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">done_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_keys</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">done_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;done_key requested but more than one key present in the environment&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">done_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_done_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The full done spec.</span>

<span class="sd">        ``full_done_spec`` is a :class:`~torchrl.data.Composite`` instance</span>
<span class="sd">        that contains all the done entries.</span>
<span class="sd">        It can be used to generate fake data with a structure that mimics the</span>
<span class="sd">        one obtained at runtime.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import gymnasium</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import GymWrapper</span>
<span class="sd">            &gt;&gt;&gt; env = GymWrapper(gymnasium.make(&quot;Pendulum-v1&quot;))</span>
<span class="sd">            &gt;&gt;&gt; env.full_done_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                done: Categorical(</span>
<span class="sd">                    shape=torch.Size([1]),</span>
<span class="sd">                    space=DiscreteBox(n=2),</span>
<span class="sd">                    device=cpu,</span>
<span class="sd">                    dtype=torch.bool,</span>
<span class="sd">                    domain=discrete),</span>
<span class="sd">                truncated: Categorical(</span>
<span class="sd">                    shape=torch.Size([1]),</span>
<span class="sd">                    space=DiscreteBox(n=2),</span>
<span class="sd">                    device=cpu,</span>
<span class="sd">                    dtype=torch.bool,</span>
<span class="sd">                    domain=discrete), device=cpu, shape=torch.Size([]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">]</span>

    <span class="nd">@full_done_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_done_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">done_spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">spec</span>

    <span class="c1"># Done spec: done specs belong to output_spec</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorSpec</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The ``done`` spec.</span>

<span class="sd">        The ``done_spec`` is always stored as a composite spec.</span>

<span class="sd">        If the done spec is provided as a simple spec, this will be returned.</span>

<span class="sd">            &gt;&gt;&gt; env.done_spec = Categorical(2, dtype=torch.bool)</span>
<span class="sd">            &gt;&gt;&gt; env.done_spec</span>
<span class="sd">            Categorical(</span>
<span class="sd">                shape=torch.Size([]),</span>
<span class="sd">                space=DiscreteBox(n=2),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                dtype=torch.bool,</span>
<span class="sd">                domain=discrete)</span>

<span class="sd">        If the done spec is provided as a composite spec and contains only one leaf,</span>
<span class="sd">        this function will return just the leaf.</span>

<span class="sd">            &gt;&gt;&gt; env.done_spec = Composite({&quot;nested&quot;: {&quot;done&quot;: Categorical(2, dtype=torch.bool)}})</span>
<span class="sd">            &gt;&gt;&gt; env.done_spec</span>
<span class="sd">            Categorical(</span>
<span class="sd">                shape=torch.Size([]),</span>
<span class="sd">                space=DiscreteBox(n=2),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                dtype=torch.bool,</span>
<span class="sd">                domain=discrete)</span>

<span class="sd">        If the done spec is provided as a composite spec and has more than one leaf,</span>
<span class="sd">        this function will return the whole spec.</span>

<span class="sd">            &gt;&gt;&gt; env.done_spec = Composite({&quot;nested&quot;: {&quot;done&quot;: Categorical(2, dtype=torch.bool), &quot;another_done&quot;: Categorical(2, dtype=torch.bool)}})</span>
<span class="sd">            &gt;&gt;&gt; env.done_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                nested: Composite(</span>
<span class="sd">                    done: Categorical(</span>
<span class="sd">                        shape=torch.Size([]),</span>
<span class="sd">                        space=DiscreteBox(n=2),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.bool,</span>
<span class="sd">                        domain=discrete),</span>
<span class="sd">                    another_done: Categorical(</span>
<span class="sd">                        shape=torch.Size([]),</span>
<span class="sd">                        space=DiscreteBox(n=2),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        dtype=torch.bool,</span>
<span class="sd">                        domain=discrete), device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([]))</span>

<span class="sd">        To always retrieve the full spec passed, use:</span>

<span class="sd">            &gt;&gt;&gt; env.output_spec[&quot;full_done_spec&quot;]</span>

<span class="sd">        This property is mutable.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs.libs.gym import GymEnv</span>
<span class="sd">            &gt;&gt;&gt; env = GymEnv(&quot;Pendulum-v1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; env.done_spec</span>
<span class="sd">            Categorical(</span>
<span class="sd">                shape=torch.Size([1]),</span>
<span class="sd">                space=DiscreteBox(n=2),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                dtype=torch.bool,</span>
<span class="sd">                domain=discrete)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">done_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">done_spec</span>

    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_done_specs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads through the done specs and makes it so that it&#39;s complete.</span>

<span class="sd">        If the done_specs contain only a ``&quot;done&quot;`` entry, a similar ``&quot;terminated&quot;`` entry is created.</span>
<span class="sd">        Same goes if only ``&quot;terminated&quot;`` key is present.</span>

<span class="sd">        If none of ``&quot;done&quot;`` and ``&quot;terminated&quot;`` can be found and the spec is not</span>
<span class="sd">        empty, nothing is changed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">full_done_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">full_done_spec</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span>
                <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>
            <span class="n">full_done_spec</span><span class="p">[</span><span class="s2">&quot;done&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Categorical</span><span class="p">(</span>
                <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="n">full_done_spec</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">full_done_spec</span><span class="p">[</span><span class="s2">&quot;terminated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Categorical</span><span class="p">(</span>
                <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="n">full_done_spec</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_done_spec</span>
            <span class="k">return</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">check_local_done</span><span class="p">(</span><span class="n">spec</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">):</span>  <span class="c1"># list to avoid error due to in-loop changes</span>
                <span class="c1"># in the case where the spec is non-empty and there is no done and no terminated, we do nothing</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;done&quot;</span> <span class="ow">and</span> <span class="s2">&quot;terminated&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;terminated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;terminated&quot;</span> <span class="ow">and</span> <span class="s2">&quot;done&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;done&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Composite</span><span class="p">):</span>
                    <span class="n">check_local_done</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">shape</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span>
                        <span class="k">continue</span>
                    <span class="c1"># checks that all shape match</span>
                    <span class="k">if</span> <span class="n">shape</span> <span class="o">!=</span> <span class="n">item</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;All shapes should match in done_spec </span><span class="si">{</span><span class="n">spec</span><span class="si">}</span><span class="s2"> (shape=</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">, key=</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">).&quot;</span>
                        <span class="p">)</span>

            <span class="c1"># if the spec is empty, we need to add a done and terminated manually</span>
            <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
                <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;done&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Categorical</span><span class="p">(</span>
                    <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span>
                <span class="p">)</span>
                <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;terminated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Categorical</span><span class="p">(</span>
                    <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">*</span><span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span>
                <span class="p">)</span>

        <span class="n">if_locked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_locked</span>
        <span class="k">if</span> <span class="n">if_locked</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_locked</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">check_local_done</span><span class="p">(</span><span class="n">full_done_spec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_done_spec</span>
        <span class="k">if</span> <span class="n">if_locked</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_locked</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span>

    <span class="nd">@done_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">TensorSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">device</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;done_spec of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2"> do not have a shape &quot;</span> <span class="sa">f</span><span class="s2">&quot;attribute.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The value of spec.shape (</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) must match the env batch size (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Composite</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span>
                <span class="n">done</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
                <span class="n">terminated</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span>
                <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;the done_spec&#39;s leaves shape cannot be empty (this error&quot;</span>
                    <span class="s2">&quot; usually comes from trying to set a reward_spec&quot;</span>
                    <span class="s2">&quot; with a null number of dimensions. Try using a multidimensional&quot;</span>
                    <span class="s2">&quot; spec instead, for instance with a singleton dimension at the tail).&quot;</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_done_specs</span><span class="p">()</span>

    <span class="c1"># observation spec: observation specs belong to output_spec</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observation_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Observation spec.</span>

<span class="sd">        Must be a :class:`torchrl.data.Composite` instance.</span>
<span class="sd">        The keys listed in the spec are directly accessible after reset and step.</span>

<span class="sd">        In TorchRL, even though they are not properly speaking &quot;observations&quot;</span>
<span class="sd">        all info, states, results of transforms etc. outputs from the environment are stored in the</span>
<span class="sd">        ``observation_spec``.</span>

<span class="sd">        Therefore, ``&quot;observation_spec&quot;`` should be thought as</span>
<span class="sd">        a generic data container for environment outputs that are not done or reward data.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs.libs.gym import GymEnv</span>
<span class="sd">            &gt;&gt;&gt; env = GymEnv(&quot;Pendulum-v1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; env.observation_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                observation: BoundedContinuous(</span>
<span class="sd">                    shape=torch.Size([3]),</span>
<span class="sd">                    space=ContinuousBox(</span>
<span class="sd">                        low=Tensor(shape=torch.Size([3]), device=cpu, dtype=torch.float32, contiguous=True),</span>
<span class="sd">                        high=Tensor(shape=torch.Size([3]), device=cpu, dtype=torch.float32, contiguous=True)),</span>
<span class="sd">                    device=cpu,</span>
<span class="sd">                    dtype=torch.float32,</span>
<span class="sd">                    domain=continuous), device=cpu, shape=torch.Size([]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">observation_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;full_observation_spec&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">observation_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">is_locked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_locked</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">observation_spec</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_observation_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">observation_spec</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">observation_spec</span>

    <span class="nd">@observation_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observation_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">TensorSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Composite</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span>
                <span class="n">observation</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The value of spec.shape (</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) must match the env batch size (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The value of spec.shape (</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) must match the env batch size (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>
        <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">_device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_observation_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">value</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_observation_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_spec</span>

    <span class="nd">@full_observation_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_observation_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observation_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="c1"># state spec: state specs belong to input_spec</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">state_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;State spec.</span>

<span class="sd">        Must be a :class:`torchrl.data.Composite` instance.</span>
<span class="sd">        The keys listed here should be provided as input alongside actions to the environment.</span>

<span class="sd">        In TorchRL, even though they are not properly speaking &quot;state&quot;</span>
<span class="sd">        all inputs to the environment that are not actions are stored in the</span>
<span class="sd">        ``state_spec``.</span>

<span class="sd">        Therefore, ``&quot;state_spec&quot;`` should be thought as</span>
<span class="sd">        a generic data container for environment inputs that are not action data.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import BraxEnv</span>
<span class="sd">            &gt;&gt;&gt; for envname in BraxEnv.available_envs:</span>
<span class="sd">            ...     break</span>
<span class="sd">            &gt;&gt;&gt; env = BraxEnv(envname)</span>
<span class="sd">            &gt;&gt;&gt; env.state_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                state: Composite(</span>
<span class="sd">                    pipeline_state: Composite(</span>
<span class="sd">                        q: UnboundedContinuous(</span>
<span class="sd">                            shape=torch.Size([15]),</span>
<span class="sd">                            space=None,</span>
<span class="sd">                            device=cpu,</span>
<span class="sd">                            dtype=torch.float32,</span>
<span class="sd">                            domain=continuous),</span>
<span class="sd">                [...], device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([]))</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_state_spec&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">state_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">is_locked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spec_locked</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">state_spec</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_state_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_spec</span>
            <span class="k">if</span> <span class="n">is_locked</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_spec_lock_</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state_spec</span>

    <span class="nd">@state_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">state_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Composite</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_state_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Composite</span><span class="p">(</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="o">.</span><span class="n">device</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Composite</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The type of an state_spec must be Composite.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The value of spec.shape (</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) must match the env batch size (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The value of spec.shape (</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) must match the env batch size (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_state_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">value</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_state_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The full state spec.</span>

<span class="sd">        ``full_state_spec`` is a :class:`~torchrl.data.Composite`` instance</span>
<span class="sd">        that contains all the state entries (ie, the input data that is not action).</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import BraxEnv</span>
<span class="sd">            &gt;&gt;&gt; for envname in BraxEnv.available_envs:</span>
<span class="sd">            ...     break</span>
<span class="sd">            &gt;&gt;&gt; env = BraxEnv(envname)</span>
<span class="sd">            &gt;&gt;&gt; env.full_state_spec</span>
<span class="sd">            Composite(</span>
<span class="sd">                state: Composite(</span>
<span class="sd">                    pipeline_state: Composite(</span>
<span class="sd">                        q: UnboundedContinuous(</span>
<span class="sd">                            shape=torch.Size([15]),</span>
<span class="sd">                            space=None,</span>
<span class="sd">                            device=cpu,</span>
<span class="sd">                            dtype=torch.float32,</span>
<span class="sd">                            domain=continuous),</span>
<span class="sd">                [...], device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([])), device=cpu, shape=torch.Size([]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_spec</span>

    <span class="nd">@full_state_spec</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_state_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="c1"># Single-env specs can be used to remove the batch size from the spec</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">batch_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of batch dimensions of the env.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">TensorSpec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorSpec</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_dims</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spec</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_dims</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">spec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_action_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the action spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_action_spec</span><span class="p">)</span>

    <span class="nd">@full_action_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_action_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_action_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">action_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorSpec</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the action spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">action_spec</span><span class="p">)</span>

    <span class="nd">@action_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">action_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">action_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_observation_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the observation spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_observation_spec</span><span class="p">)</span>

    <span class="nd">@full_observation_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_observation_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_observation_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observation_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the observation spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">observation_spec</span><span class="p">)</span>

    <span class="nd">@observation_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observation_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observation_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_reward_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the reward spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_reward_spec</span><span class="p">)</span>

    <span class="nd">@full_reward_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_reward_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_reward_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reward_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorSpec</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the reward spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reward_spec</span><span class="p">)</span>

    <span class="nd">@reward_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reward_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reward_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_done_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the done spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span><span class="p">)</span>

    <span class="nd">@full_done_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_done_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorSpec</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the done spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">done_spec</span><span class="p">)</span>

    <span class="nd">@done_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">done_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the output spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">)</span>

    <span class="nd">@output_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">output_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the input spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">)</span>

    <span class="nd">@input_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">input_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_state_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the state spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_state_spec</span><span class="p">)</span>

    <span class="nd">@full_state_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_state_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_state_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">state_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorSpec</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the state spec of the env as if it had no batch dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_single_env_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_spec</span><span class="p">)</span>

    <span class="nd">@state_spec_unbatched</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">state_spec_unbatched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">+</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_spec</span> <span class="o">=</span> <span class="n">spec</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_skip_tensordict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
        <span class="c1"># Creates a &quot;skip&quot; tensordict, ie a placeholder for when a step is skipped</span>
        <span class="n">next_tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="n">next_tensordict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_observation_spec</span><span class="o">.</span><span class="n">zero</span><span class="p">())</span>
        <span class="n">next_tensordict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_reward_spec</span><span class="o">.</span><span class="n">zero</span><span class="p">())</span>

        <span class="c1"># Copy the data from tensordict in `next`</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">select_and_clone</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">device</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">_fast_apply</span><span class="p">(</span>
            <span class="n">select_and_clone</span><span class="p">,</span>
            <span class="n">next_tensordict</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">filter_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">is_leaf</span><span class="o">=</span><span class="n">_is_leaf_nontensor</span><span class="p">,</span>
            <span class="n">named</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">nested_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">next_tensordict</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span><span class="o">.</span><span class="n">filter_empty_</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="EnvBase.step"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.step">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Makes a step in the environment.</span>

<span class="sd">        Step accepts a single argument, tensordict, which usually carries an &#39;action&#39; key which indicates the action</span>
<span class="sd">        to be taken.</span>
<span class="sd">        Step will call an out-place private method, _step, which is the method to be re-written by EnvBase subclasses.</span>

<span class="sd">        Args:</span>
<span class="sd">            tensordict (TensorDictBase): Tensordict containing the action to be taken.</span>
<span class="sd">                If the input tensordict contains a ``&quot;next&quot;`` entry, the values contained in it</span>
<span class="sd">                will prevail over the newly computed values. This gives a mechanism</span>
<span class="sd">                to override the underlying computations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the input tensordict, modified in place with the resulting observations, done state and reward</span>
<span class="sd">            (+ others if needed).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sanity check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_tensordict_shape</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
        <span class="n">partial_steps</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_step&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">next_tensordict</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">partial_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tensordict_batch_size</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span><span class="p">:</span>
                <span class="c1"># Batched envs have their own way of dealing with this - batched envs that are not batched-locked may fail here</span>
                <span class="k">if</span> <span class="n">partial_steps</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">partial_steps</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tensordict_batch_size</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">batch_size</span>
                    <span class="n">partial_steps</span> <span class="o">=</span> <span class="n">partial_steps</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">tensordict_batch_size</span><span class="p">)</span>
                    <span class="n">tensordict</span> <span class="o">=</span> <span class="n">tensordict</span><span class="p">[</span><span class="n">partial_steps</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">partial_steps</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">next_tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip_tensordic</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># trust that the _step can handle this!</span>
                    <span class="n">tensordict</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;_step&quot;</span><span class="p">,</span> <span class="n">partial_steps</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tensordict_batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tensordict_batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>

        <span class="n">next_preset</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">next_tensordict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">next_tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
            <span class="n">next_tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_proc_data</span><span class="p">(</span><span class="n">next_tensordict</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">next_preset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># tensordict could already have a &quot;next&quot; key</span>
            <span class="c1"># this could be done more efficiently by not excluding but just passing</span>
            <span class="c1"># the necessary keys</span>
            <span class="n">next_tensordict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">next_preset</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="o">*</span><span class="n">next_tensordict</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">tensordict</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">next_tensordict</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">partial_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tensordict_batch_size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">new_zeros</span><span class="p">(</span><span class="n">tensordict_batch_size</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">tensordict_batch_size</span> <span class="o">==</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">select_and_clone</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">device</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

                <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">tensordict</span><span class="o">.</span><span class="n">_fast_apply</span><span class="p">(</span>
                        <span class="n">select_and_clone</span><span class="p">,</span>
                        <span class="n">result</span><span class="p">,</span>
                        <span class="n">device</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                        <span class="n">filter_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">batch_size</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                        <span class="n">is_leaf</span><span class="o">=</span><span class="n">_is_leaf_nontensor</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">partial_steps</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">result</span><span class="p">[</span><span class="n">partial_steps</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensordict</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">tensordict</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_complete_done</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">done_spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">TensorDictBase</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Completes the data structure at step time to put missing done keys.&quot;&quot;&quot;</span>
        <span class="c1"># by default, if a done key is missing, it is assumed that it is False</span>
        <span class="c1"># except in 2 cases: (1) there is a &quot;done&quot; but no &quot;terminated&quot; or (2)</span>
        <span class="c1"># there is a &quot;terminated&quot; but no &quot;done&quot;.</span>
        <span class="k">if</span> <span class="n">done_spec</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">leading_dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="o">-</span><span class="n">done_spec</span><span class="o">.</span><span class="n">ndim</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leading_dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">done_spec</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>  <span class="c1"># noqa: B007</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Composite</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_complete_done</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">leading_dim</span><span class="p">,</span> <span class="o">*</span><span class="n">item</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="n">vals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># complete missing dones: we only want to do that if we don&#39;t have enough done values</span>
            <span class="n">data_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">done_spec_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">done_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">done_spec</span><span class="o">.</span><span class="n">items</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;done&quot;</span>
                    <span class="ow">and</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="s2">&quot;terminated&quot;</span> <span class="ow">in</span> <span class="n">done_spec_keys</span>
                    <span class="ow">and</span> <span class="s2">&quot;terminated&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_keys</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="s2">&quot;truncated&quot;</span> <span class="ow">in</span> <span class="n">data_keys</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="s2">&quot;Cannot infer the value of terminated when only done and truncated are present.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;terminated&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                    <span class="n">data_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;terminated&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;terminated&quot;</span>
                    <span class="ow">and</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="s2">&quot;done&quot;</span> <span class="ow">in</span> <span class="n">done_spec_keys</span>
                    <span class="ow">and</span> <span class="s2">&quot;done&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_keys</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="s2">&quot;truncated&quot;</span> <span class="ow">in</span> <span class="n">data_keys</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">|</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;truncated&quot;</span><span class="p">)</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                    <span class="n">data_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_keys</span><span class="p">:</span>
                    <span class="c1"># we must keep this here: we only want to fill with 0s if we&#39;re sure</span>
                    <span class="c1"># done should not be copied to terminated or terminated to done</span>
                    <span class="c1"># in this case, just fill with 0s</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">zero</span><span class="p">(</span><span class="n">leading_dim</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_step_proc_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">next_tensordict_out</span><span class="p">):</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">leading_batch_size</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">next_tensordict_out</span><span class="o">.</span><span class="n">batch_size</span><span class="p">[:</span><span class="o">-</span><span class="n">dims</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dims</span>
            <span class="k">else</span> <span class="n">next_tensordict_out</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">reward_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward_keys</span><span class="p">:</span>
            <span class="n">reward</span> <span class="o">=</span> <span class="n">next_tensordict_out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reward_key</span><span class="p">)</span>
            <span class="n">expected_reward_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="o">*</span><span class="n">leading_batch_size</span><span class="p">,</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_reward_spec&quot;</span><span class="p">][</span><span class="n">reward_key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">actual_reward_shape</span> <span class="o">=</span> <span class="n">reward</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">actual_reward_shape</span> <span class="o">!=</span> <span class="n">expected_reward_shape</span><span class="p">:</span>
                <span class="n">reward</span> <span class="o">=</span> <span class="n">reward</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">expected_reward_shape</span><span class="p">)</span>
                <span class="n">next_tensordict_out</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">reward_key</span><span class="p">,</span> <span class="n">reward</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_complete_done</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span><span class="p">,</span> <span class="n">next_tensordict_out</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_type_checks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_spec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">obs</span> <span class="o">=</span> <span class="n">next_tensordict_out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">spec</span><span class="o">.</span><span class="n">type_check</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">reward_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">next_tensordict_out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reward_key</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
                    <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span>
                        <span class="n">unravel_key</span><span class="p">((</span><span class="s2">&quot;full_reward_spec&quot;</span><span class="p">,</span> <span class="n">reward_key</span><span class="p">))</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;expected reward.dtype to be </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="n">unravel_key</span><span class="p">((</span><span class="s1">&#39;full_reward_spec&#39;</span><span class="p">,</span><span class="n">reward_key</span><span class="p">))]</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">next_tensordict_out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reward_key</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

            <span class="k">for</span> <span class="n">done_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">next_tensordict_out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">done_key</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
                    <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">,</span> <span class="n">done_key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;expected done.dtype to be </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s1">&#39;full_done_spec&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">done_key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> but got </span><span class="si">{</span><span class="n">next_tensordict_out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">done_key</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">next_tensordict_out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_in_keys_to_exclude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_in_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache_in_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                    <span class="n">tensordict</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_in_keys</span>

<div class="viewcode-block" id="EnvBase.register_gym"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.register_gym">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">register_gym</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">entry_point</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Transform</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa: F821</span>
        <span class="n">info_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">to_numpy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reward_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nondeterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_episode_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order_enforce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">autoreset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">disable_env_checker</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">apply_api_compatibility</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Registers an environment in gym(nasium).</span>

<span class="sd">        This method is designed with the following scopes in mind:</span>

<span class="sd">        - Incorporate a TorchRL-first environment in a framework that uses Gym;</span>
<span class="sd">        - Incorporate another environment (eg, DeepMind Control, Brax, Jumanji, ...)</span>
<span class="sd">          in a framework that uses Gym.</span>

<span class="sd">        Args:</span>
<span class="sd">            id (str): the name of the environment. Should follow the</span>
<span class="sd">                `gym naming convention &lt;https://www.gymlibrary.dev/content/environment_creation/#registering-envs&gt;`_.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            entry_point (callable, optional): the entry point to build the environment.</span>
<span class="sd">                If none is passed, the parent class will be used as entry point.</span>
<span class="sd">                Typically, this is used to register an environment that does not</span>
<span class="sd">                necessarily inherit from the base being used:</span>

<span class="sd">                    &gt;&gt;&gt; from torchrl.envs import DMControlEnv</span>
<span class="sd">                    &gt;&gt;&gt; DMControlEnv.register_gym(&quot;DMC-cheetah-v0&quot;, env_name=&quot;cheetah&quot;, task=&quot;run&quot;)</span>
<span class="sd">                    &gt;&gt;&gt; # equivalently</span>
<span class="sd">                    &gt;&gt;&gt; EnvBase.register_gym(&quot;DMC-cheetah-v0&quot;, entry_point=DMControlEnv, env_name=&quot;cheetah&quot;, task=&quot;run&quot;)</span>

<span class="sd">            transform (torchrl.envs.Transform): a transform (or list of transforms</span>
<span class="sd">                within a :class:`torchrl.envs.Compose` instance) to be used with the env.</span>
<span class="sd">                This arg can be passed during a call to :func:`~gym.make` (see</span>
<span class="sd">                example below).</span>
<span class="sd">            info_keys (List[NestedKey], optional): if provided, these keys will</span>
<span class="sd">                be used to build the info dictionary and will be excluded from</span>
<span class="sd">                the observation keys.</span>
<span class="sd">                This arg can be passed during a call to :func:`~gym.make` (see</span>
<span class="sd">                example below).</span>

<span class="sd">                .. warning::</span>
<span class="sd">                  It may be the case that using ``info_keys`` makes a spec empty</span>
<span class="sd">                  because the content has been moved to the info dictionary.</span>
<span class="sd">                  Gym does not like empty ``Dict`` in the specs, so this empty</span>
<span class="sd">                  content should be removed with :class:`~torchrl.envs.transforms.RemoveEmptySpecs`.</span>

<span class="sd">            backend (str, optional): the backend. Can be either `&quot;gym&quot;` or `&quot;gymnasium&quot;`</span>
<span class="sd">                or any other backend compatible with :class:`~torchrl.envs.libs.gym.set_gym_backend`.</span>
<span class="sd">            to_numpy (bool, optional): if ``True``, the result of calls to `step` and</span>
<span class="sd">                `reset` will be mapped to numpy arrays. Defaults to ``False``</span>
<span class="sd">                (results are tensors).</span>
<span class="sd">                This arg can be passed during a call to :func:`~gym.make` (see</span>
<span class="sd">                example below).</span>
<span class="sd">            reward_threshold (:obj:`float`, optional): [Gym kwarg] The reward threshold</span>
<span class="sd">                considered to have learnt an environment.</span>
<span class="sd">            nondeterministic (bool, optional): [Gym kwarg If the environment is nondeterministic</span>
<span class="sd">                (even with knowledge of the initial seed and all actions). Defaults to</span>
<span class="sd">                ``False``.</span>
<span class="sd">            max_episode_steps (int, optional): [Gym kwarg] The maximum number</span>
<span class="sd">                of episodes steps before truncation. Used by the Time Limit wrapper.</span>
<span class="sd">            order_enforce (bool, optional): [Gym &gt;= 0.14] Whether the order</span>
<span class="sd">                enforcer wrapper should be applied to ensure users run functions</span>
<span class="sd">                in the correct order.</span>
<span class="sd">                Defaults to ``True``.</span>
<span class="sd">            autoreset (bool, optional): [Gym &gt;= 0.14] Whether the autoreset wrapper</span>
<span class="sd">                should be added such that reset does not need to be called.</span>
<span class="sd">                Defaults to ``False``.</span>
<span class="sd">            disable_env_checker: [Gym &gt;= 0.14] Whether the environment</span>
<span class="sd">                checker should be disabled for the environment. Defaults to ``False``.</span>
<span class="sd">            apply_api_compatibility: [Gym &gt;= 0.26] If to apply the `StepAPICompatibility` wrapper.</span>
<span class="sd">                Defaults to ``False``.</span>
<span class="sd">            **kwargs: arbitrary keyword arguments which are passed to the environment constructor.</span>

<span class="sd">        .. note::</span>
<span class="sd">            TorchRL&#39;s environment do not have the concept of an ``&quot;info&quot;`` dictionary,</span>
<span class="sd">            as ``TensorDict`` offers all the storage requirements deemed necessary</span>
<span class="sd">            in most training settings. Still, you can use the ``info_keys`` argument to</span>
<span class="sd">            have a fine grained control over what is deemed to be considered</span>
<span class="sd">            as an observation and what should be seen as info.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Register the &quot;cheetah&quot; env from DMControl with the &quot;run&quot; task</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import DMControlEnv</span>
<span class="sd">            &gt;&gt;&gt; import torch</span>
<span class="sd">            &gt;&gt;&gt; DMControlEnv.register_gym(&quot;DMC-cheetah-v0&quot;, to_numpy=False, backend=&quot;gym&quot;, env_name=&quot;cheetah&quot;, task_name=&quot;run&quot;)</span>
<span class="sd">            &gt;&gt;&gt; import gym</span>
<span class="sd">            &gt;&gt;&gt; envgym = gym.make(&quot;DMC-cheetah-v0&quot;)</span>
<span class="sd">            &gt;&gt;&gt; envgym.seed(0)</span>
<span class="sd">            &gt;&gt;&gt; torch.manual_seed(0)</span>
<span class="sd">            &gt;&gt;&gt; envgym.reset()</span>
<span class="sd">            ({&#39;position&#39;: tensor([-0.0855,  0.0215, -0.0881, -0.0412, -0.1101,  0.0080,  0.0254,  0.0424],</span>
<span class="sd">                   dtype=torch.float64), &#39;velocity&#39;: tensor([ 1.9609e-02, -1.9776e-04, -1.6347e-03,  3.3842e-02,  2.5338e-02,</span>
<span class="sd">                     3.3064e-02,  1.0381e-04,  7.6656e-05,  1.0204e-02],</span>
<span class="sd">                   dtype=torch.float64)}, {})</span>
<span class="sd">            &gt;&gt;&gt; envgym.step(envgym.action_space.sample())</span>
<span class="sd">            ({&#39;position&#39;: tensor([-0.0833,  0.0275, -0.0612, -0.0770, -0.1256,  0.0082,  0.0186,  0.0476],</span>
<span class="sd">                   dtype=torch.float64), &#39;velocity&#39;: tensor([ 0.2221,  0.2256,  0.5930,  2.6937, -3.5865, -1.5479,  0.0187, -0.6825,</span>
<span class="sd">                     0.5224], dtype=torch.float64)}, tensor([0.0018], dtype=torch.float64), tensor([False]), tensor([False]), {})</span>
<span class="sd">            &gt;&gt;&gt; # same environment with observation stacked</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import CatTensors</span>
<span class="sd">            &gt;&gt;&gt; envgym = gym.make(&quot;DMC-cheetah-v0&quot;, transform=CatTensors(in_keys=[&quot;position&quot;, &quot;velocity&quot;], out_key=&quot;observation&quot;))</span>
<span class="sd">            &gt;&gt;&gt; envgym.reset()</span>
<span class="sd">            ({&#39;observation&#39;: tensor([-0.1005,  0.0335, -0.0268,  0.0133, -0.0627,  0.0074, -0.0488, -0.0353,</span>
<span class="sd">                    -0.0075, -0.0069,  0.0098, -0.0058,  0.0033, -0.0157, -0.0004, -0.0381,</span>
<span class="sd">                    -0.0452], dtype=torch.float64)}, {})</span>
<span class="sd">            &gt;&gt;&gt; # same environment with numpy observations</span>
<span class="sd">            &gt;&gt;&gt; envgym = gym.make(&quot;DMC-cheetah-v0&quot;, transform=CatTensors(in_keys=[&quot;position&quot;, &quot;velocity&quot;], out_key=&quot;observation&quot;), to_numpy=True)</span>
<span class="sd">            &gt;&gt;&gt; envgym.reset()</span>
<span class="sd">            ({&#39;observation&#39;: array([-0.11355747,  0.04257728,  0.00408397,  0.04155852, -0.0389733 ,</span>
<span class="sd">                   -0.01409826, -0.0978704 , -0.08808327,  0.03970837,  0.00535434,</span>
<span class="sd">                   -0.02353762,  0.05116226,  0.02788907,  0.06848346,  0.05154399,</span>
<span class="sd">                    0.0371798 ,  0.05128025])}, {})</span>
<span class="sd">            &gt;&gt;&gt; # If gymnasium is installed, we can register the environment there too.</span>
<span class="sd">            &gt;&gt;&gt; DMControlEnv.register_gym(&quot;DMC-cheetah-v0&quot;, to_numpy=False, backend=&quot;gymnasium&quot;, env_name=&quot;cheetah&quot;, task_name=&quot;run&quot;)</span>
<span class="sd">            &gt;&gt;&gt; import gymnasium</span>
<span class="sd">            &gt;&gt;&gt; envgym = gymnasium.make(&quot;DMC-cheetah-v0&quot;)</span>
<span class="sd">            &gt;&gt;&gt; envgym.seed(0)</span>
<span class="sd">            &gt;&gt;&gt; torch.manual_seed(0)</span>
<span class="sd">            &gt;&gt;&gt; envgym.reset()</span>
<span class="sd">            ({&#39;position&#39;: tensor([-0.0855,  0.0215, -0.0881, -0.0412, -0.1101,  0.0080,  0.0254,  0.0424],</span>
<span class="sd">                   dtype=torch.float64), &#39;velocity&#39;: tensor([ 1.9609e-02, -1.9776e-04, -1.6347e-03,  3.3842e-02,  2.5338e-02,</span>
<span class="sd">                     3.3064e-02,  1.0381e-04,  7.6656e-05,  1.0204e-02],</span>
<span class="sd">                   dtype=torch.float64)}, {})</span>

<span class="sd">        .. note::</span>
<span class="sd">            This feature also works for stateless environments (eg, :class:`~torchrl.envs.BraxEnv`).</span>

<span class="sd">                &gt;&gt;&gt; import gymnasium</span>
<span class="sd">                &gt;&gt;&gt; import torch</span>
<span class="sd">                &gt;&gt;&gt; from tensordict import TensorDict</span>
<span class="sd">                &gt;&gt;&gt; from torchrl.envs import BraxEnv, SelectTransform</span>
<span class="sd">                &gt;&gt;&gt;</span>
<span class="sd">                &gt;&gt;&gt; # get action for dydactic purposes</span>
<span class="sd">                &gt;&gt;&gt; env = BraxEnv(&quot;ant&quot;, batch_size=[2])</span>
<span class="sd">                &gt;&gt;&gt; env.set_seed(0)</span>
<span class="sd">                &gt;&gt;&gt; torch.manual_seed(0)</span>
<span class="sd">                &gt;&gt;&gt; td = env.rollout(10)</span>
<span class="sd">                &gt;&gt;&gt;</span>
<span class="sd">                &gt;&gt;&gt; actions = td.get(&quot;action&quot;)</span>
<span class="sd">                &gt;&gt;&gt;</span>
<span class="sd">                &gt;&gt;&gt; # register env</span>
<span class="sd">                &gt;&gt;&gt; env.register_gym(&quot;Brax-Ant-v0&quot;, env_name=&quot;ant&quot;, batch_size=[2], info_keys=[&quot;state&quot;])</span>
<span class="sd">                &gt;&gt;&gt; gym_env = gymnasium.make(&quot;Brax-Ant-v0&quot;)</span>
<span class="sd">                &gt;&gt;&gt; gym_env.seed(0)</span>
<span class="sd">                &gt;&gt;&gt; torch.manual_seed(0)</span>
<span class="sd">                &gt;&gt;&gt;</span>
<span class="sd">                &gt;&gt;&gt; gym_env.reset()</span>
<span class="sd">                &gt;&gt;&gt; obs = []</span>
<span class="sd">                &gt;&gt;&gt; for i in range(10):</span>
<span class="sd">                ...     obs, reward, terminated, truncated, info = gym_env.step(td[..., i].get(&quot;action&quot;))</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.libs.gym</span><span class="w"> </span><span class="kn">import</span> <span class="n">gym_backend</span><span class="p">,</span> <span class="n">set_gym_backend</span>

        <span class="k">if</span> <span class="n">backend</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">gym_backend</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">set_gym_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_register_gym</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
                <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                <span class="n">info_keys</span><span class="o">=</span><span class="n">info_keys</span><span class="p">,</span>
                <span class="n">to_numpy</span><span class="o">=</span><span class="n">to_numpy</span><span class="p">,</span>
                <span class="n">reward_threshold</span><span class="o">=</span><span class="n">reward_threshold</span><span class="p">,</span>
                <span class="n">nondeterministic</span><span class="o">=</span><span class="n">nondeterministic</span><span class="p">,</span>
                <span class="n">max_episode_steps</span><span class="o">=</span><span class="n">max_episode_steps</span><span class="p">,</span>
                <span class="n">order_enforce</span><span class="o">=</span><span class="n">order_enforce</span><span class="p">,</span>
                <span class="n">autoreset</span><span class="o">=</span><span class="n">autoreset</span><span class="p">,</span>
                <span class="n">disable_env_checker</span><span class="o">=</span><span class="n">disable_env_checker</span><span class="p">,</span>
                <span class="n">apply_api_compatibility</span><span class="o">=</span><span class="n">apply_api_compatibility</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span></div>

    <span class="n">_GYM_UNRECOGNIZED_KWARG</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;The keyword argument </span><span class="si">{}</span><span class="s2"> is not compatible with gym version </span><span class="si">{}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="nd">@implement_for</span><span class="p">(</span><span class="s2">&quot;gym&quot;</span><span class="p">,</span> <span class="s2">&quot;0.26&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">class_method</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_register_gym</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">,</span>
        <span class="n">entry_point</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Transform</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa: F821</span>
        <span class="n">info_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">to_numpy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reward_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nondeterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_episode_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order_enforce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">autoreset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">disable_env_checker</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">apply_api_compatibility</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">gym</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.libs._gym_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_TorchRLGymWrapper</span>

        <span class="k">if</span> <span class="n">entry_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entry_point</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="n">entry_point</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">_TorchRLGymWrapper</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">info_keys</span><span class="o">=</span><span class="n">info_keys</span><span class="p">,</span>
            <span class="n">to_numpy</span><span class="o">=</span><span class="n">to_numpy</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">gym</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">reward_threshold</span><span class="o">=</span><span class="n">reward_threshold</span><span class="p">,</span>
            <span class="n">nondeterministic</span><span class="o">=</span><span class="n">nondeterministic</span><span class="p">,</span>
            <span class="n">max_episode_steps</span><span class="o">=</span><span class="n">max_episode_steps</span><span class="p">,</span>
            <span class="n">order_enforce</span><span class="o">=</span><span class="n">order_enforce</span><span class="p">,</span>
            <span class="n">autoreset</span><span class="o">=</span><span class="n">autoreset</span><span class="p">,</span>
            <span class="n">disable_env_checker</span><span class="o">=</span><span class="n">disable_env_checker</span><span class="p">,</span>
            <span class="n">apply_api_compatibility</span><span class="o">=</span><span class="n">apply_api_compatibility</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@implement_for</span><span class="p">(</span><span class="s2">&quot;gym&quot;</span><span class="p">,</span> <span class="s2">&quot;0.25&quot;</span><span class="p">,</span> <span class="s2">&quot;0.26&quot;</span><span class="p">,</span> <span class="n">class_method</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_register_gym</span><span class="p">(</span>  <span class="c1"># noqa: F811</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">,</span>
        <span class="n">entry_point</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Transform</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa: F821</span>
        <span class="n">info_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">to_numpy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reward_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nondeterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_episode_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order_enforce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">autoreset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">disable_env_checker</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">apply_api_compatibility</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">gym</span>

        <span class="k">if</span> <span class="n">apply_api_compatibility</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_GYM_UNRECOGNIZED_KWARG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;apply_api_compatibility&quot;</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">__version__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.libs._gym_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_TorchRLGymWrapper</span>

        <span class="k">if</span> <span class="n">entry_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entry_point</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="n">entry_point</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">_TorchRLGymWrapper</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">info_keys</span><span class="o">=</span><span class="n">info_keys</span><span class="p">,</span>
            <span class="n">to_numpy</span><span class="o">=</span><span class="n">to_numpy</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">gym</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">reward_threshold</span><span class="o">=</span><span class="n">reward_threshold</span><span class="p">,</span>
            <span class="n">nondeterministic</span><span class="o">=</span><span class="n">nondeterministic</span><span class="p">,</span>
            <span class="n">max_episode_steps</span><span class="o">=</span><span class="n">max_episode_steps</span><span class="p">,</span>
            <span class="n">order_enforce</span><span class="o">=</span><span class="n">order_enforce</span><span class="p">,</span>
            <span class="n">autoreset</span><span class="o">=</span><span class="n">autoreset</span><span class="p">,</span>
            <span class="n">disable_env_checker</span><span class="o">=</span><span class="n">disable_env_checker</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@implement_for</span><span class="p">(</span><span class="s2">&quot;gym&quot;</span><span class="p">,</span> <span class="s2">&quot;0.24&quot;</span><span class="p">,</span> <span class="s2">&quot;0.25&quot;</span><span class="p">,</span> <span class="n">class_method</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_register_gym</span><span class="p">(</span>  <span class="c1"># noqa: F811</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">,</span>
        <span class="n">entry_point</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Transform</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa: F821</span>
        <span class="n">info_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">to_numpy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reward_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nondeterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_episode_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order_enforce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">autoreset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">disable_env_checker</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">apply_api_compatibility</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">gym</span>

        <span class="k">if</span> <span class="n">apply_api_compatibility</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_GYM_UNRECOGNIZED_KWARG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;apply_api_compatibility&quot;</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">__version__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">disable_env_checker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_GYM_UNRECOGNIZED_KWARG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;disable_env_checker&quot;</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">__version__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.libs._gym_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_TorchRLGymWrapper</span>

        <span class="k">if</span> <span class="n">entry_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entry_point</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="n">entry_point</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">_TorchRLGymWrapper</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">info_keys</span><span class="o">=</span><span class="n">info_keys</span><span class="p">,</span>
            <span class="n">to_numpy</span><span class="o">=</span><span class="n">to_numpy</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">gym</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">reward_threshold</span><span class="o">=</span><span class="n">reward_threshold</span><span class="p">,</span>
            <span class="n">nondeterministic</span><span class="o">=</span><span class="n">nondeterministic</span><span class="p">,</span>
            <span class="n">max_episode_steps</span><span class="o">=</span><span class="n">max_episode_steps</span><span class="p">,</span>
            <span class="n">order_enforce</span><span class="o">=</span><span class="n">order_enforce</span><span class="p">,</span>
            <span class="n">autoreset</span><span class="o">=</span><span class="n">autoreset</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@implement_for</span><span class="p">(</span><span class="s2">&quot;gym&quot;</span><span class="p">,</span> <span class="s2">&quot;0.21&quot;</span><span class="p">,</span> <span class="s2">&quot;0.24&quot;</span><span class="p">,</span> <span class="n">class_method</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_register_gym</span><span class="p">(</span>  <span class="c1"># noqa: F811</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">,</span>
        <span class="n">entry_point</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Transform</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa: F821</span>
        <span class="n">info_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">to_numpy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reward_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nondeterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_episode_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order_enforce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">autoreset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">disable_env_checker</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">apply_api_compatibility</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">gym</span>

        <span class="k">if</span> <span class="n">apply_api_compatibility</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_GYM_UNRECOGNIZED_KWARG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;apply_api_compatibility&quot;</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">__version__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">disable_env_checker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_GYM_UNRECOGNIZED_KWARG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;disable_env_checker&quot;</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">__version__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">autoreset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_GYM_UNRECOGNIZED_KWARG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;autoreset&quot;</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.libs._gym_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_TorchRLGymWrapper</span>

        <span class="k">if</span> <span class="n">entry_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entry_point</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="n">entry_point</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">_TorchRLGymWrapper</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">info_keys</span><span class="o">=</span><span class="n">info_keys</span><span class="p">,</span>
            <span class="n">to_numpy</span><span class="o">=</span><span class="n">to_numpy</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">gym</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">reward_threshold</span><span class="o">=</span><span class="n">reward_threshold</span><span class="p">,</span>
            <span class="n">nondeterministic</span><span class="o">=</span><span class="n">nondeterministic</span><span class="p">,</span>
            <span class="n">max_episode_steps</span><span class="o">=</span><span class="n">max_episode_steps</span><span class="p">,</span>
            <span class="n">order_enforce</span><span class="o">=</span><span class="n">order_enforce</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@implement_for</span><span class="p">(</span><span class="s2">&quot;gym&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;0.21&quot;</span><span class="p">,</span> <span class="n">class_method</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_register_gym</span><span class="p">(</span>  <span class="c1"># noqa: F811</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">,</span>
        <span class="n">entry_point</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Transform</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa: F821</span>
        <span class="n">info_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">to_numpy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reward_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nondeterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_episode_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order_enforce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">autoreset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">disable_env_checker</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">apply_api_compatibility</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">gym</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.libs._gym_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_TorchRLGymWrapper</span>

        <span class="k">if</span> <span class="n">order_enforce</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_GYM_UNRECOGNIZED_KWARG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;order_enforce&quot;</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">disable_env_checker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_GYM_UNRECOGNIZED_KWARG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;disable_env_checker&quot;</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">__version__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">autoreset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_GYM_UNRECOGNIZED_KWARG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;autoreset&quot;</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">apply_api_compatibility</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_GYM_UNRECOGNIZED_KWARG</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;apply_api_compatibility&quot;</span><span class="p">,</span> <span class="n">gym</span><span class="o">.</span><span class="n">__version__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">entry_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entry_point</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="n">entry_point</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">_TorchRLGymWrapper</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">info_keys</span><span class="o">=</span><span class="n">info_keys</span><span class="p">,</span>
            <span class="n">to_numpy</span><span class="o">=</span><span class="n">to_numpy</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">gym</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">reward_threshold</span><span class="o">=</span><span class="n">reward_threshold</span><span class="p">,</span>
            <span class="n">nondeterministic</span><span class="o">=</span><span class="n">nondeterministic</span><span class="p">,</span>
            <span class="n">max_episode_steps</span><span class="o">=</span><span class="n">max_episode_steps</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@implement_for</span><span class="p">(</span><span class="s2">&quot;gymnasium&quot;</span><span class="p">,</span> <span class="n">class_method</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_register_gym</span><span class="p">(</span>  <span class="c1"># noqa: F811</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">,</span>
        <span class="n">entry_point</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Transform</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa: F821</span>
        <span class="n">info_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">to_numpy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reward_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nondeterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_episode_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order_enforce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">autoreset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">disable_env_checker</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">apply_api_compatibility</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">gymnasium</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.libs._gym_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_TorchRLGymnasiumWrapper</span>

        <span class="k">if</span> <span class="n">entry_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entry_point</span> <span class="o">=</span> <span class="bp">cls</span>

        <span class="n">entry_point</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">_TorchRLGymnasiumWrapper</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">info_keys</span><span class="o">=</span><span class="n">info_keys</span><span class="p">,</span>
            <span class="n">to_numpy</span><span class="o">=</span><span class="n">to_numpy</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">gymnasium</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span>
            <span class="n">entry_point</span><span class="o">=</span><span class="n">entry_point</span><span class="p">,</span>
            <span class="n">reward_threshold</span><span class="o">=</span><span class="n">reward_threshold</span><span class="p">,</span>
            <span class="n">nondeterministic</span><span class="o">=</span><span class="n">nondeterministic</span><span class="p">,</span>
            <span class="n">max_episode_steps</span><span class="o">=</span><span class="n">max_episode_steps</span><span class="p">,</span>
            <span class="n">order_enforce</span><span class="o">=</span><span class="n">order_enforce</span><span class="p">,</span>
            <span class="n">autoreset</span><span class="o">=</span><span class="n">autoreset</span><span class="p">,</span>
            <span class="n">disable_env_checker</span><span class="o">=</span><span class="n">disable_env_checker</span><span class="p">,</span>
            <span class="n">apply_api_compatibility</span><span class="o">=</span><span class="n">apply_api_compatibility</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="EnvBase.forward"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.forward">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;EnvBase.forward is not implemented. If you ended here during a call to `ParallelEnv(...)`, please use &quot;</span>
            <span class="s2">&quot;a constructor such as `ParallelEnv(num_env, lambda env=env: env)` instead. &quot;</span>
            <span class="s2">&quot;Batched envs require constructors because environment instances may not always be serializable.&quot;</span>
        <span class="p">)</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_step</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="EnvBase.reset"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.reset">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resets the environment.</span>

<span class="sd">        As for step and _step, only the private method :obj:`_reset` should be overwritten by EnvBase subclasses.</span>

<span class="sd">        Args:</span>
<span class="sd">            tensordict (TensorDictBase, optional): tensordict to be used to contain the resulting new observation.</span>
<span class="sd">                In some cases, this input can also be used to pass argument to the reset function.</span>
<span class="sd">            kwargs (optional): other arguments to be passed to the native</span>
<span class="sd">                reset function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tensordict (or the input tensordict, if any), modified in place with the resulting observations.</span>

<span class="sd">        .. note:: `reset` should not be overwritten by :class:`~torchrl.envs.EnvBase` subclasses. The method to</span>
<span class="sd">            modify is :meth:`~torchrl.envs.EnvBase._reset`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assert_tensordict_shape</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>

        <span class="n">select_reset_only</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;select_reset_only&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">select_reset_only</span> <span class="ow">and</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># When making rollouts with step_and_maybe_reset, it can happen that a tensordict has</span>
            <span class="c1"># keys that are used by reset to optionally set the reset state (eg, the fen in chess). If that&#39;s the</span>
            <span class="c1"># case and we don&#39;t throw them away here, reset will just be a no-op (put the env in the state reached</span>
            <span class="c1"># during the previous step).</span>
            <span class="c1"># Therefore, maybe_reset tells reset to temporarily hide the non-reset keys.</span>
            <span class="c1"># To make step_and_maybe_reset handle custom reset states, some version of TensorDictPrimer should be used.</span>
            <span class="n">tensordict_reset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span>
                <span class="n">tensordict</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">reset_keys</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tensordict_reset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="n">tensordict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># We assume that this is done properly</span>
        <span class="c1"># if reset.device != self.device:</span>
        <span class="c1">#     reset = reset.to(self.device, non_blocking=True)</span>
        <span class="k">if</span> <span class="n">tensordict_reset</span> <span class="ow">is</span> <span class="n">tensordict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;EnvBase._reset should return outplace changes to the input &quot;</span>
                <span class="s2">&quot;tensordict. Consider emptying the TensorDict first (e.g. tensordict.empty()) &quot;</span>
                <span class="s2">&quot;inside _reset before writing new tensors onto this new instance.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tensordict_reset</span><span class="p">,</span> <span class="n">TensorDictBase</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;env._reset returned an object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tensordict_reset</span><span class="p">)</span><span class="si">}</span><span class="s2"> but a TensorDict was expected.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_proc_data</span><span class="p">(</span><span class="n">tensordict</span><span class="p">,</span> <span class="n">tensordict_reset</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reset_proc_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">,</span> <span class="n">tensordict_reset</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_complete_done</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span><span class="p">,</span> <span class="n">tensordict_reset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_check_done</span><span class="p">(</span><span class="n">tensordict</span><span class="p">,</span> <span class="n">tensordict_reset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_update_during_reset</span><span class="p">(</span><span class="n">tensordict_reset</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensordict_reset</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reset_check_done</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">,</span> <span class="n">tensordict_reset</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks the done status after reset.</span>

<span class="sd">        If _reset signals were passed, we check that the env is not done for these</span>
<span class="sd">        indices.</span>

<span class="sd">        We also check that the input tensordict contained ``&quot;done&quot;``s if the</span>
<span class="sd">        reset is partial and incomplete.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we iterate over (reset_key, (done_key, truncated_key)) and check that all</span>
        <span class="c1"># values where reset was true now have a done set to False.</span>
        <span class="c1"># If no reset was present, all done and truncated must be False</span>
        <span class="k">for</span> <span class="n">reset_key</span><span class="p">,</span> <span class="n">done_key_group</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reset_keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_keys_groups</span><span class="p">):</span>
            <span class="n">reset_value</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">tensordict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reset_key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">reset_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">done_key</span> <span class="ow">in</span> <span class="n">done_key_group</span><span class="p">:</span>
                    <span class="n">done_val</span> <span class="o">=</span> <span class="n">tensordict_reset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">done_key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">done_val</span><span class="p">[</span><span class="n">reset_value</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allow_done_after_reset</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Env done entry &#39;</span><span class="si">{</span><span class="n">done_key</span><span class="si">}</span><span class="s2">&#39; was (partially) True after reset on specified &#39;_reset&#39; dimensions. This is not allowed.&quot;</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">done_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="n">done_val</span><span class="p">[</span><span class="o">~</span><span class="n">reset_value</span><span class="p">]</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                    <span class="p">):</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;A partial `&#39;_reset&#39;` key has been passed to `reset` (</span><span class="si">{</span><span class="n">reset_key</span><span class="si">}</span><span class="s2">), &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;but the corresponding done_key (</span><span class="si">{</span><span class="n">done_key</span><span class="si">}</span><span class="s2">) was not present in the input &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;tensordict. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;This is discouraged, since the input tensordict should contain &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;all the data not being reset.&quot;</span>
                        <span class="p">)</span>
                        <span class="c1"># we set the done val to tensordict, to make sure that</span>
                        <span class="c1"># _update_during_reset does not pad the value</span>
                        <span class="n">tensordict</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">done_key</span><span class="p">,</span> <span class="n">done_val</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allow_done_after_reset</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">done_key</span> <span class="ow">in</span> <span class="n">done_key_group</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tensordict_reset</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">done_key</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;The done entry &#39;</span><span class="si">{</span><span class="n">done_key</span><span class="si">}</span><span class="s2">&#39; was (partially) True after a call to reset() in env </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">numel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span>

<div class="viewcode-block" id="EnvBase.set_seed"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.set_seed">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_seed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">static_seed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the seed of the environment and returns the next seed to be used (which is the input seed if a single environment is present).</span>

<span class="sd">        Args:</span>
<span class="sd">            seed (int): seed to be set. The seed is set only locally in the environment. To handle the global seed,</span>
<span class="sd">                see :func:`~torch.manual_seed`.</span>
<span class="sd">            static_seed (bool, optional): if ``True``, the seed is not incremented.</span>
<span class="sd">                Defaults to False</span>

<span class="sd">        Returns:</span>
<span class="sd">            integer representing the &quot;next seed&quot;: i.e. the seed that should be</span>
<span class="sd">            used for another environment if created concomitantly to this environment.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">static_seed</span><span class="p">:</span>
            <span class="n">new_seed</span> <span class="o">=</span> <span class="n">seed_generator</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">new_seed</span>
        <span class="k">return</span> <span class="n">seed</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assert_tensordict_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">!=</span> <span class="p">()</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected a tensordict with shape==env.batch_size, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">tensordict</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="EnvBase.all_actions"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.all_actions">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">all_actions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates all possible actions from the action spec.</span>

<span class="sd">        This only works in environments with fully discrete actions.</span>

<span class="sd">        Args:</span>
<span class="sd">            tensordict (TensorDictBase, optional): If given, :meth:`~.reset`</span>
<span class="sd">                is called with this tensordict.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tensordict object with the &quot;action&quot; entry updated with a batch of</span>
<span class="sd">            all possible actions. The actions are stacked together in the</span>
<span class="sd">            leading dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_action_spec</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">use_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="EnvBase.rand_action"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.rand_action">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">rand_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a random action given the action_spec attribute.</span>

<span class="sd">        Args:</span>
<span class="sd">            tensordict (TensorDictBase, optional): tensordict where the resulting action should be written.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tensordict object with the &quot;action&quot; entry updated with a random</span>
<span class="sd">            sample from the action-spec.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_locked</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="ow">and</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if we can&#39;t infer the batch-size from the env, take it from tensordict</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
                <span class="c1"># if tensordict wasn&#39;t provided, we assume empty batch size</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([])</span>
            <span class="k">elif</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
                <span class="c1"># if tensordict is not None and the env has a batch size, their shape must match</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;The input tensordict and the env have a different batch size: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;env.batch_size=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2"> and tensordict.batch_size=</span><span class="si">{</span><span class="n">tensordict</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Non batch-locked environment require the env batch-size to be either empty or to&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; match the tensordict one.&quot;</span>
                <span class="p">)</span>
        <span class="c1"># We generate the action from the full_action_spec</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_action_spec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span>
        <span class="n">tensordict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensordict</span></div>

<div class="viewcode-block" id="EnvBase.rand_step"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.rand_step">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">rand_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a random step in the environment given the action_spec attribute.</span>

<span class="sd">        Args:</span>
<span class="sd">            tensordict (TensorDictBase, optional): tensordict where the resulting info should be written.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tensordict object with the new observation after a random step in the environment. The action will</span>
<span class="sd">            be stored with the &quot;action&quot; key.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_action</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">specs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Composite</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a Composite container where all the environment are present.</span>

<span class="sd">        This feature allows one to create an environment, retrieve all of the specs in a single data container and then</span>
<span class="sd">        erase the environment from the workspace.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Composite</span><span class="p">(</span>
            <span class="n">output_spec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">,</span>
            <span class="n">input_spec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_cache_value</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_has_dynamic_specs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_has_dynamic_specs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">)</span>

<div class="viewcode-block" id="EnvBase.rollout"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.rollout">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">rollout</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">policy</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TensorDictBase</span><span class="p">],</span> <span class="n">TensorDictBase</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TensorDictBase</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">auto_reset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">auto_cast_to_device</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">break_when_any_done</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">break_when_all_done</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_contiguous</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">set_truncated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">trust_policy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Executes a rollout in the environment.</span>

<span class="sd">        The function will return as soon as any of the contained environments</span>
<span class="sd">        reaches any of the done states.</span>

<span class="sd">        Args:</span>
<span class="sd">            max_steps (int): maximum number of steps to be executed. The actual number of steps can be smaller if</span>
<span class="sd">                the environment reaches a done state before max_steps have been executed.</span>
<span class="sd">            policy (callable, optional): callable to be called to compute the desired action.</span>
<span class="sd">                If no policy is provided, actions will be called using :obj:`env.rand_step()`.</span>
<span class="sd">                The policy can be any callable that reads either a tensordict or</span>
<span class="sd">                the entire sequence of observation entries __sorted as__ the ``env.observation_spec.keys()``.</span>
<span class="sd">                Defaults to `None`.</span>
<span class="sd">            callback (Callable[[TensorDict], Any], optional): function to be called at each iteration with the given</span>
<span class="sd">                TensorDict. Defaults to ``None``. The output of ``callback`` will not be collected, it is the user</span>
<span class="sd">                responsibility to save any result within the callback call if data needs to be carried over beyond</span>
<span class="sd">                the call to ``rollout``.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            auto_reset (bool, optional): if ``True``, the contained environments will be reset before starting the</span>
<span class="sd">                rollout. If ``False``, then the rollout will continue from a previous state, which requires the</span>
<span class="sd">                ``tensordict`` argument to be passed with the previous rollout. Default is ``True``.</span>
<span class="sd">            auto_cast_to_device (bool, optional): if ``True``, the device of the tensordict is automatically cast to the</span>
<span class="sd">                policy device before the policy is used. Default is ``False``.</span>
<span class="sd">            break_when_any_done (bool): if ``True``, break when any of the contained environments reaches any of the</span>
<span class="sd">                done states. If ``False``, then the done environments are reset automatically. Default is ``True``.</span>

<span class="sd">                .. seealso:: The :ref:`Partial resets &lt;ref_partial_resets&gt;` of the documentation gives more</span>
<span class="sd">                    information about partial resets.</span>

<span class="sd">            break_when_all_done (bool, optional): if ``True``, break if all of the contained environments reach any</span>
<span class="sd">                of the done states. If ``False``, break if at least one environment reaches any of the done states.</span>
<span class="sd">                Default is ``False``.</span>

<span class="sd">                .. seealso:: The :ref:`Partial steps &lt;ref_partial_steps&gt;` of the documentation gives more</span>
<span class="sd">                    information about partial resets.</span>

<span class="sd">            return_contiguous (bool): if False, a LazyStackedTensorDict will be returned. Default is `True` if</span>
<span class="sd">                the env does not have dynamic specs, otherwise `False`.</span>
<span class="sd">            tensordict (TensorDict, optional): if ``auto_reset`` is False, an initial</span>
<span class="sd">                tensordict must be provided. Rollout will check if this tensordict has done flags and reset the</span>
<span class="sd">                environment in those dimensions (if needed).</span>
<span class="sd">                This normally should not occur if ``tensordict`` is the output of a reset, but can occur</span>
<span class="sd">                if ``tensordict`` is the last step of a previous rollout.</span>
<span class="sd">                A ``tensordict`` can also be provided when ``auto_reset=True`` if metadata need to be passed</span>
<span class="sd">                to the ``reset`` method, such as a batch-size or a device for stateless environments.</span>
<span class="sd">            set_truncated (bool, optional): if ``True``, ``&quot;truncated&quot;`` and ``&quot;done&quot;`` keys will be set to</span>
<span class="sd">                ``True`` after completion of the rollout. If no ``&quot;truncated&quot;`` is found within the</span>
<span class="sd">                ``done_spec``, an exception is raised.</span>
<span class="sd">                Truncated keys can be set through ``env.add_truncated_keys``.</span>
<span class="sd">                Defaults to ``False``.</span>
<span class="sd">            trust_policy (bool, optional): if ``True``, a non-TensorDictModule policy will be trusted to be</span>
<span class="sd">                assumed to be compatible with the collector. This defaults to ``True`` for CudaGraphModules</span>
<span class="sd">                and ``False`` otherwise.</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorDict object containing the resulting trajectory.</span>

<span class="sd">        The data returned will be marked with a &quot;time&quot; dimension name for the last</span>
<span class="sd">        dimension of the tensordict (at the ``env.ndim`` index).</span>

<span class="sd">        ``rollout`` is quite handy to display what the data structure of the</span>
<span class="sd">        environment looks like.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # Using rollout without a policy</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs.libs.gym import GymEnv</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs.transforms import TransformedEnv, StepCounter</span>
<span class="sd">            &gt;&gt;&gt; env = TransformedEnv(GymEnv(&quot;Pendulum-v1&quot;), StepCounter(max_steps=20))</span>
<span class="sd">            &gt;&gt;&gt; rollout = env.rollout(max_steps=1000)</span>
<span class="sd">            &gt;&gt;&gt; print(rollout)</span>
<span class="sd">            TensorDict(</span>
<span class="sd">                fields={</span>
<span class="sd">                    action: Tensor(shape=torch.Size([20, 1]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                    done: Tensor(shape=torch.Size([20, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                    next: TensorDict(</span>
<span class="sd">                        fields={</span>
<span class="sd">                            done: Tensor(shape=torch.Size([20, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                            observation: Tensor(shape=torch.Size([20, 3]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            reward: Tensor(shape=torch.Size([20, 1]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            step_count: Tensor(shape=torch.Size([20, 1]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                            truncated: Tensor(shape=torch.Size([20, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                        batch_size=torch.Size([20]),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        is_shared=False),</span>
<span class="sd">                    observation: Tensor(shape=torch.Size([20, 3]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                    step_count: Tensor(shape=torch.Size([20, 1]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                    truncated: Tensor(shape=torch.Size([20, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                batch_size=torch.Size([20]),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                is_shared=False)</span>
<span class="sd">            &gt;&gt;&gt; print(rollout.names)</span>
<span class="sd">            [&#39;time&#39;]</span>
<span class="sd">            &gt;&gt;&gt; # with envs that contain more dimensions</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import SerialEnv</span>
<span class="sd">            &gt;&gt;&gt; env = SerialEnv(3, lambda: TransformedEnv(GymEnv(&quot;Pendulum-v1&quot;), StepCounter(max_steps=20)))</span>
<span class="sd">            &gt;&gt;&gt; rollout = env.rollout(max_steps=1000)</span>
<span class="sd">            &gt;&gt;&gt; print(rollout)</span>
<span class="sd">            TensorDict(</span>
<span class="sd">                fields={</span>
<span class="sd">                    action: Tensor(shape=torch.Size([3, 20, 1]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                    done: Tensor(shape=torch.Size([3, 20, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                    next: TensorDict(</span>
<span class="sd">                        fields={</span>
<span class="sd">                            done: Tensor(shape=torch.Size([3, 20, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                            observation: Tensor(shape=torch.Size([3, 20, 3]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            reward: Tensor(shape=torch.Size([3, 20, 1]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            step_count: Tensor(shape=torch.Size([3, 20, 1]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                            truncated: Tensor(shape=torch.Size([3, 20, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                        batch_size=torch.Size([3, 20]),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        is_shared=False),</span>
<span class="sd">                    observation: Tensor(shape=torch.Size([3, 20, 3]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                    step_count: Tensor(shape=torch.Size([3, 20, 1]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                    truncated: Tensor(shape=torch.Size([3, 20, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                batch_size=torch.Size([3, 20]),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                is_shared=False)</span>
<span class="sd">            &gt;&gt;&gt; print(rollout.names)</span>
<span class="sd">            [None, &#39;time&#39;]</span>

<span class="sd">        Using a policy (a regular :class:`~torch.nn.Module` or a :class:`~tensordict.nn.TensorDictModule`)</span>
<span class="sd">        is also easy:</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torch import nn</span>
<span class="sd">            &gt;&gt;&gt; env = GymEnv(&quot;CartPole-v1&quot;, categorical_action_encoding=True)</span>
<span class="sd">            &gt;&gt;&gt; class ArgMaxModule(nn.Module):</span>
<span class="sd">            ...     def forward(self, values):</span>
<span class="sd">            ...         return values.argmax(-1)</span>
<span class="sd">            &gt;&gt;&gt; n_obs = env.observation_spec[&quot;observation&quot;].shape[-1]</span>
<span class="sd">            &gt;&gt;&gt; n_act = env.action_spec.n</span>
<span class="sd">            &gt;&gt;&gt; # A deterministic policy</span>
<span class="sd">            &gt;&gt;&gt; policy = nn.Sequential(</span>
<span class="sd">            ...     nn.Linear(n_obs, n_act),</span>
<span class="sd">            ...     ArgMaxModule())</span>
<span class="sd">            &gt;&gt;&gt; env.rollout(max_steps=10, policy=policy)</span>
<span class="sd">            TensorDict(</span>
<span class="sd">                fields={</span>
<span class="sd">                    action: Tensor(shape=torch.Size([10]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                    done: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                    next: TensorDict(</span>
<span class="sd">                        fields={</span>
<span class="sd">                            done: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                            observation: Tensor(shape=torch.Size([10, 4]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            reward: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            terminated: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                            truncated: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                        batch_size=torch.Size([10]),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        is_shared=False),</span>
<span class="sd">                    observation: Tensor(shape=torch.Size([10, 4]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                    terminated: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                    truncated: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                batch_size=torch.Size([10]),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                is_shared=False)</span>
<span class="sd">            &gt;&gt;&gt; # Under the hood, rollout will wrap the policy in a TensorDictModule</span>
<span class="sd">            &gt;&gt;&gt; # To speed things up we can do that ourselves</span>
<span class="sd">            &gt;&gt;&gt; from tensordict.nn import TensorDictModule</span>
<span class="sd">            &gt;&gt;&gt; policy = TensorDictModule(policy, in_keys=list(env.observation_spec.keys()), out_keys=[&quot;action&quot;])</span>
<span class="sd">            &gt;&gt;&gt; env.rollout(max_steps=10, policy=policy)</span>
<span class="sd">            TensorDict(</span>
<span class="sd">                fields={</span>
<span class="sd">                    action: Tensor(shape=torch.Size([10]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                    done: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                    next: TensorDict(</span>
<span class="sd">                        fields={</span>
<span class="sd">                            done: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                            observation: Tensor(shape=torch.Size([10, 4]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            reward: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            terminated: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                            truncated: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                        batch_size=torch.Size([10]),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        is_shared=False),</span>
<span class="sd">                    observation: Tensor(shape=torch.Size([10, 4]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                    terminated: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                    truncated: Tensor(shape=torch.Size([10, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                batch_size=torch.Size([10]),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                is_shared=False)</span>


<span class="sd">        In some instances, contiguous tensordict cannot be obtained because</span>
<span class="sd">        they cannot be stacked. This can happen when the data returned at</span>
<span class="sd">        each step may have a different shape, or when different environments</span>
<span class="sd">        are executed together. In that case, ``return_contiguous=False``</span>
<span class="sd">        will cause the returned tensordict to be a lazy stack of tensordicts:</span>

<span class="sd">        Examples of non-contiguous rollout:</span>
<span class="sd">            &gt;&gt;&gt; rollout = env.rollout(4, return_contiguous=False)</span>
<span class="sd">            &gt;&gt;&gt; print(rollout)</span>
<span class="sd">            LazyStackedTensorDict(</span>
<span class="sd">                fields={</span>
<span class="sd">                    action: Tensor(shape=torch.Size([3, 4, 1]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                    done: Tensor(shape=torch.Size([3, 4, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                    next: LazyStackedTensorDict(</span>
<span class="sd">                        fields={</span>
<span class="sd">                            done: Tensor(shape=torch.Size([3, 4, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                            observation: Tensor(shape=torch.Size([3, 4, 3]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            reward: Tensor(shape=torch.Size([3, 4, 1]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            step_count: Tensor(shape=torch.Size([3, 4, 1]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                            truncated: Tensor(shape=torch.Size([3, 4, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                        batch_size=torch.Size([3, 4]),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        is_shared=False),</span>
<span class="sd">                    observation: Tensor(shape=torch.Size([3, 4, 3]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                    step_count: Tensor(shape=torch.Size([3, 4, 1]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                    truncated: Tensor(shape=torch.Size([3, 4, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                batch_size=torch.Size([3, 4]),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                is_shared=False)</span>
<span class="sd">                &gt;&gt;&gt; print(rollout.names)</span>
<span class="sd">                [None, &#39;time&#39;]</span>

<span class="sd">        Rollouts can be used in a loop to emulate data collection.</span>
<span class="sd">        To do so, you need to pass as input the last tensordict coming from the previous rollout after calling</span>
<span class="sd">        :func:`~torchrl.envs.utils.step_mdp` on it.</span>

<span class="sd">        Examples of data collection rollouts:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import GymEnv, step_mdp</span>
<span class="sd">            &gt;&gt;&gt; env = GymEnv(&quot;CartPole-v1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; epochs = 10</span>
<span class="sd">            &gt;&gt;&gt; input_td = env.reset()</span>
<span class="sd">            &gt;&gt;&gt; for i in range(epochs):</span>
<span class="sd">            ...     rollout_td = env.rollout(</span>
<span class="sd">            ...         max_steps=100,</span>
<span class="sd">            ...         break_when_any_done=False,</span>
<span class="sd">            ...         auto_reset=False,</span>
<span class="sd">            ...         tensordict=input_td,</span>
<span class="sd">            ...     )</span>
<span class="sd">            ...     input_td = step_mdp(</span>
<span class="sd">            ...         rollout_td[..., -1],</span>
<span class="sd">            ...     )</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">break_when_any_done</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># True by default</span>
            <span class="k">if</span> <span class="n">break_when_all_done</span><span class="p">:</span>  <span class="c1"># all overrides</span>
                <span class="n">break_when_any_done</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">break_when_any_done</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">break_when_all_done</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># There is no case where break_when_all_done is True by default</span>
            <span class="n">break_when_all_done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">break_when_all_done</span> <span class="ow">and</span> <span class="n">break_when_any_done</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot have both break_when_all_done and break_when_any_done True at the same time.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">return_contiguous</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">return_contiguous</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_dynamic_specs</span>
        <span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">policy</span> <span class="o">=</span> <span class="n">_make_compatible_policy</span><span class="p">(</span>
                <span class="n">policy</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observation_spec</span><span class="p">,</span>
                <span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">fast_wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">trust_policy</span><span class="o">=</span><span class="n">trust_policy</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">auto_cast_to_device</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">policy_device</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">parameters</span><span class="p">())</span><span class="o">.</span><span class="n">device</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">StopIteration</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                    <span class="n">policy_device</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">policy_device</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rand_action</span>
            <span class="n">policy_device</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">env_device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span>

        <span class="k">if</span> <span class="n">auto_reset</span><span class="p">:</span>
            <span class="n">tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;tensordict must be provided when auto_reset is False&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maybe_reset</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tensordict&quot;</span><span class="p">:</span> <span class="n">tensordict</span><span class="p">,</span>
            <span class="s2">&quot;auto_cast_to_device&quot;</span><span class="p">:</span> <span class="n">auto_cast_to_device</span><span class="p">,</span>
            <span class="s2">&quot;max_steps&quot;</span><span class="p">:</span> <span class="n">max_steps</span><span class="p">,</span>
            <span class="s2">&quot;policy&quot;</span><span class="p">:</span> <span class="n">policy</span><span class="p">,</span>
            <span class="s2">&quot;policy_device&quot;</span><span class="p">:</span> <span class="n">policy_device</span><span class="p">,</span>
            <span class="s2">&quot;env_device&quot;</span><span class="p">:</span> <span class="n">env_device</span><span class="p">,</span>
            <span class="s2">&quot;callback&quot;</span><span class="p">:</span> <span class="n">callback</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">break_when_any_done</span> <span class="ow">or</span> <span class="n">break_when_all_done</span><span class="p">:</span>
            <span class="n">tensordicts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rollout_stop_early</span><span class="p">(</span>
                <span class="n">break_when_all_done</span><span class="o">=</span><span class="n">break_when_all_done</span><span class="p">,</span>
                <span class="n">break_when_any_done</span><span class="o">=</span><span class="n">break_when_any_done</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tensordicts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rollout_nonstop</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="k">if</span> <span class="n">tensordict</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="k">if</span> <span class="n">return_contiguous</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">out_td</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">tensordicts</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="s2">&quot;The shapes of the tensors to stack is incompatible&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_dynamic_specs</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;The environment specs are dynamic. Call rollout with return_contiguous=False.&quot;</span>
                    <span class="p">)</span>
                <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_td</span> <span class="o">=</span> <span class="n">LazyStackedTensorDict</span><span class="o">.</span><span class="n">maybe_dense_stack</span><span class="p">(</span>
                <span class="n">tensordicts</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">set_truncated</span><span class="p">:</span>
            <span class="n">found_truncated</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_ends_with</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">out_td</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="n">out_td</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">_replace_last</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;done&quot;</span><span class="p">)))</span>
                    <span class="n">val</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="n">out_td</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">out_td</span><span class="o">.</span><span class="n">set</span><span class="p">((</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">val</span><span class="p">)</span>
                    <span class="n">out_td</span><span class="o">.</span><span class="n">set</span><span class="p">((</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">_replace_last</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;done&quot;</span><span class="p">)),</span> <span class="n">val</span> <span class="o">|</span> <span class="n">done</span><span class="p">)</span>
                    <span class="n">found_truncated</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found_truncated</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;set_truncated was set to True but no truncated key could be found. &quot;</span>
                    <span class="s2">&quot;Make sure a &#39;truncated&#39; entry was set in the environment &quot;</span>
                    <span class="s2">&quot;full_done_keys using `env.add_truncated_keys()`.&quot;</span>
                <span class="p">)</span>

        <span class="n">out_td</span><span class="o">.</span><span class="n">refine_names</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_td</span></div>

<div class="viewcode-block" id="EnvBase.add_truncated_keys"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.add_truncated_keys">[docs]</a>    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_truncated_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnvBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds truncated keys to the environment.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_keys</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">truncated_key</span> <span class="o">=</span> <span class="n">_replace_last</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span><span class="p">[</span><span class="n">truncated_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t find done keys. done_spec=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">full_done_specs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="EnvBase.step_mdp"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.step_mdp">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">step_mdp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">next_tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Advances the environment state by one step using the provided `next_tensordict`.</span>

<span class="sd">        This method updates the environment&#39;s state by transitioning from the current</span>
<span class="sd">        state to the next, as defined by the `next_tensordict`. The resulting tensordict</span>
<span class="sd">        includes updated observations and any other relevant state information, with</span>
<span class="sd">        keys managed according to the environment&#39;s specifications.</span>

<span class="sd">        Internally, this method utilizes a precomputed :class:`~torchrl.envs.utils._StepMDP` instance to efficiently</span>
<span class="sd">        handle the transition of state, observation, action, reward, and done keys. The</span>
<span class="sd">        :class:`~torchrl.envs.utils._StepMDP` class optimizes the process by precomputing the keys to include and</span>
<span class="sd">        exclude, reducing runtime overhead during repeated calls. The :class:`~torchrl.envs.utils._StepMDP` instance</span>
<span class="sd">        is created with `exclude_action=False`, meaning that action keys are retained in</span>
<span class="sd">        the root tensordict.</span>

<span class="sd">        Args:</span>
<span class="sd">            next_tensordict (TensorDictBase): A tensordict containing the state of the</span>
<span class="sd">                environment at the next time step. This tensordict should include keys</span>
<span class="sd">                for observations, actions, rewards, and done flags, as defined by the</span>
<span class="sd">                environment&#39;s specifications.</span>

<span class="sd">        Returns:</span>
<span class="sd">            TensorDictBase: A new tensordict representing the environment state after</span>
<span class="sd">            advancing by one step.</span>

<span class="sd">        .. note:: The method ensures that the environment&#39;s key specifications are validated</span>
<span class="sd">              against the provided `next_tensordict`, issuing warnings if discrepancies</span>
<span class="sd">              are found.</span>

<span class="sd">        .. note:: This method is designed to work efficiently with environments that have</span>
<span class="sd">              consistent key specifications, leveraging the `_StepMDP` class to minimize</span>
<span class="sd">              overhead.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import GymEnv</span>
<span class="sd">            &gt;&gt;&gt; env = GymEnv(&quot;Pendulum-1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; data = env.reset()</span>
<span class="sd">            &gt;&gt;&gt; for i in range(10):</span>
<span class="sd">            ...     # compute action</span>
<span class="sd">            ...     env.rand_action(data)</span>
<span class="sd">            ...     # Perform action</span>
<span class="sd">            ...     next_data = env.step(reset_data)</span>
<span class="sd">            ...     data = env.step_mdp(next_data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_mdp</span><span class="p">(</span><span class="n">next_tensordict</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="nd">@_cache_value</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_step_mdp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_StepMDP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_action</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rollout_stop_early</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">break_when_any_done</span><span class="p">,</span>
        <span class="n">break_when_all_done</span><span class="p">,</span>
        <span class="n">tensordict</span><span class="p">,</span>
        <span class="n">auto_cast_to_device</span><span class="p">,</span>
        <span class="n">max_steps</span><span class="p">,</span>
        <span class="n">policy</span><span class="p">,</span>
        <span class="n">policy_device</span><span class="p">,</span>
        <span class="n">env_device</span><span class="p">,</span>
        <span class="n">callback</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Get the sync func</span>
        <span class="k">if</span> <span class="n">auto_cast_to_device</span><span class="p">:</span>
            <span class="n">sync_func</span> <span class="o">=</span> <span class="n">_get_sync_func</span><span class="p">(</span><span class="n">policy_device</span><span class="p">,</span> <span class="n">env_device</span><span class="p">)</span>
        <span class="n">tensordicts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">partial_steps</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_steps</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">auto_cast_to_device</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">policy_device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tensordict</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">policy_device</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">sync_func</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tensordict</span><span class="o">.</span><span class="n">clear_device_</span><span class="p">()</span>
            <span class="c1"># In case policy(..) does not modify in-place - no-op for TensorDict and related</span>
            <span class="n">tensordict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">policy</span><span class="p">(</span><span class="n">tensordict</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">auto_cast_to_device</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">env_device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tensordict</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">env_device</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">sync_func</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tensordict</span><span class="o">.</span><span class="n">clear_device_</span><span class="p">()</span>
            <span class="n">tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
            <span class="n">td_append</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">break_when_all_done</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">partial_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">partial_steps</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="c1"># At least one step is partial</span>
                    <span class="n">td_append</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_step&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="n">td_append</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">partial_steps</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">td_append</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">td_append</span><span class="p">,</span> <span class="n">tensordicts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="p">)</span>

            <span class="n">tensordicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">td_append</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">max_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># we don&#39;t truncate as one could potentially continue the run</span>
                <span class="k">break</span>
            <span class="n">tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_mdp</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">break_when_any_done</span><span class="p">:</span>
                <span class="c1"># done and truncated are in done_keys</span>
                <span class="c1"># We read if any key is done.</span>
                <span class="n">any_done</span> <span class="o">=</span> <span class="n">_terminated_or_truncated</span><span class="p">(</span>
                    <span class="n">tensordict</span><span class="p">,</span>
                    <span class="n">full_done_spec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">],</span>
                    <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">any_done</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Write the &#39;_step&#39; entry, indicating which step is to be undertaken</span>
                <span class="n">_terminated_or_truncated</span><span class="p">(</span>
                    <span class="n">tensordict</span><span class="p">,</span>
                    <span class="n">full_done_spec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">],</span>
                    <span class="n">key</span><span class="o">=</span><span class="s2">&quot;_neg_step&quot;</span><span class="p">,</span>
                    <span class="n">write_full_false</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># This is what differentiates _step and _reset: we need to flip _step False -&gt; True</span>
                <span class="n">partial_step_curr</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_neg_step&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">partial_step_curr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">partial_step_curr</span> <span class="o">=</span> <span class="o">~</span><span class="n">partial_step_curr</span>
                    <span class="n">partial_steps</span> <span class="o">=</span> <span class="n">partial_steps</span> <span class="o">&amp;</span> <span class="n">partial_step_curr</span>
                <span class="k">if</span> <span class="n">partial_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">partial_steps</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="k">break</span>
                    <span class="c1"># Write the final _step entry</span>
                    <span class="n">tensordict</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;_step&quot;</span><span class="p">,</span> <span class="n">partial_steps</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensordicts</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_rollout_nonstop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">tensordict</span><span class="p">,</span>
        <span class="n">auto_cast_to_device</span><span class="p">,</span>
        <span class="n">max_steps</span><span class="p">,</span>
        <span class="n">policy</span><span class="p">,</span>
        <span class="n">policy_device</span><span class="p">,</span>
        <span class="n">env_device</span><span class="p">,</span>
        <span class="n">callback</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">auto_cast_to_device</span><span class="p">:</span>
            <span class="n">sync_func</span> <span class="o">=</span> <span class="n">_get_sync_func</span><span class="p">(</span><span class="n">policy_device</span><span class="p">,</span> <span class="n">env_device</span><span class="p">)</span>
        <span class="n">tensordicts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tensordict_</span> <span class="o">=</span> <span class="n">tensordict</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_steps</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">auto_cast_to_device</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">policy_device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tensordict_</span> <span class="o">=</span> <span class="n">tensordict_</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">policy_device</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">sync_func</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tensordict_</span><span class="o">.</span><span class="n">clear_device_</span><span class="p">()</span>
            <span class="c1"># In case policy(..) does not modify in-place - no-op for TensorDict and related</span>
            <span class="n">tensordict_</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">policy</span><span class="p">(</span><span class="n">tensordict_</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">auto_cast_to_device</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">env_device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tensordict_</span> <span class="o">=</span> <span class="n">tensordict_</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">env_device</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">sync_func</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tensordict_</span><span class="o">.</span><span class="n">clear_device_</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">max_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">tensordict_</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tensordict</span><span class="p">,</span> <span class="n">tensordict_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_and_maybe_reset</span><span class="p">(</span><span class="n">tensordict_</span><span class="p">)</span>
            <span class="n">tensordicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">max_steps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># we don&#39;t truncate as one could potentially continue the run</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tensordicts</span>

<div class="viewcode-block" id="EnvBase.step_and_maybe_reset"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.step_and_maybe_reset">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">step_and_maybe_reset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">TensorDictBase</span><span class="p">,</span> <span class="n">TensorDictBase</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Runs a step in the environment and (partially) resets it if needed.</span>

<span class="sd">        Args:</span>
<span class="sd">            tensordict (TensorDictBase): an input data structure for the :meth:`step`</span>
<span class="sd">                method.</span>

<span class="sd">        This method allows to easily code non-stopping rollout functions.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.envs import ParallelEnv, GymEnv</span>
<span class="sd">            &gt;&gt;&gt; def rollout(env, n):</span>
<span class="sd">            ...     data_ = env.reset()</span>
<span class="sd">            ...     result = []</span>
<span class="sd">            ...     for i in range(n):</span>
<span class="sd">            ...         data, data_ = env.step_and_maybe_reset(data_)</span>
<span class="sd">            ...         result.append(data)</span>
<span class="sd">            ...     return torch.stack(result)</span>
<span class="sd">            &gt;&gt;&gt; env = ParallelEnv(2, lambda: GymEnv(&quot;CartPole-v1&quot;))</span>
<span class="sd">            &gt;&gt;&gt; print(rollout(env, 2))</span>
<span class="sd">            TensorDict(</span>
<span class="sd">                fields={</span>
<span class="sd">                    done: Tensor(shape=torch.Size([2, 2, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                    next: TensorDict(</span>
<span class="sd">                        fields={</span>
<span class="sd">                            done: Tensor(shape=torch.Size([2, 2, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                            observation: Tensor(shape=torch.Size([2, 2, 4]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            reward: Tensor(shape=torch.Size([2, 2, 1]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                            terminated: Tensor(shape=torch.Size([2, 2, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                            truncated: Tensor(shape=torch.Size([2, 2, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                        batch_size=torch.Size([2, 2]),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        is_shared=False),</span>
<span class="sd">                    observation: Tensor(shape=torch.Size([2, 2, 4]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                    terminated: Tensor(shape=torch.Size([2, 2, 1]), device=cpu, dtype=torch.bool, is_shared=False),</span>
<span class="sd">                    truncated: Tensor(shape=torch.Size([2, 2, 1]), device=cpu, dtype=torch.bool, is_shared=False)},</span>
<span class="sd">                batch_size=torch.Size([2, 2]),</span>
<span class="sd">                device=cpu,</span>
<span class="sd">                is_shared=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="n">tensordict</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">tensordict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
        <span class="c1"># done and truncated are in done_keys</span>
        <span class="c1"># We read if any key is done.</span>
        <span class="n">tensordict_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_mdp</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
        <span class="n">tensordict_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maybe_reset</span><span class="p">(</span><span class="n">tensordict_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensordict</span><span class="p">,</span> <span class="n">tensordict_</span></div>

    <span class="nd">@property</span>
    <span class="nd">@_cache_value</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_simple_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">key_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">_simple_done</span> <span class="o">=</span> <span class="n">key_set</span> <span class="o">==</span> <span class="p">{</span>
            <span class="s2">&quot;done&quot;</span><span class="p">,</span>
            <span class="s2">&quot;truncated&quot;</span><span class="p">,</span>
            <span class="s2">&quot;terminated&quot;</span><span class="p">,</span>
        <span class="p">}</span> <span class="ow">or</span> <span class="n">key_set</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;done&quot;</span><span class="p">,</span> <span class="s2">&quot;terminated&quot;</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">_simple_done</span>

<div class="viewcode-block" id="EnvBase.any_done"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.any_done">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">any_done</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the tensordict is in a &quot;done&quot; state (or if an element of the batch is).</span>

<span class="sd">        Writes the result under the `&quot;_reset&quot;` entry.</span>

<span class="sd">        Returns: a bool indicating whether there is an element in the tensordict that is marked</span>
<span class="sd">            as done.</span>

<span class="sd">        .. note:: The tensordict passed should be a `&quot;next&quot;` tensordict or equivalent -- i.e., it should not</span>
<span class="sd">            contain a `&quot;next&quot;` value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_done</span><span class="p">:</span>
            <span class="n">done</span> <span class="o">=</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">_get_str</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">done</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">any_done</span> <span class="o">=</span> <span class="n">done</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">any_done</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">any_done</span><span class="p">:</span>
                <span class="n">tensordict</span><span class="o">.</span><span class="n">_set_str</span><span class="p">(</span>
                    <span class="s2">&quot;_reset&quot;</span><span class="p">,</span>
                    <span class="n">done</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span>
                    <span class="n">validated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">non_blocking</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">any_done</span> <span class="o">=</span> <span class="n">_terminated_or_truncated</span><span class="p">(</span>
                <span class="n">tensordict</span><span class="p">,</span>
                <span class="n">full_done_spec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">],</span>
                <span class="n">key</span><span class="o">=</span><span class="s2">&quot;_reset&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">any_done</span></div>

<div class="viewcode-block" id="EnvBase.maybe_reset"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.maybe_reset">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">maybe_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks the done keys of the input tensordict and, if needed, resets the environment where it is done.</span>

<span class="sd">        Args:</span>
<span class="sd">            tensordict (TensorDictBase): a tensordict coming from the output of :func:`~torchrl.envs.utils.step_mdp`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tensordict that is identical to the input where the environment was</span>
<span class="sd">            not reset and contains the new reset data where the environment was reset.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">any_done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">any_done</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">any_done</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">tensordict</span><span class="p">,</span> <span class="n">select_reset_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensordict</span></div>

<div class="viewcode-block" id="EnvBase.empty_cache"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.empty_cache">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">empty_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Erases all the cached values.</span>

<span class="sd">        For regular envs, the key lists (reward, done etc) are cached, but in some cases</span>
<span class="sd">        they may change during the execution of the code (eg, when adding a transform).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="nd">@_cache_value</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of reset keys.</span>

<span class="sd">        Reset keys are keys that indicate partial reset, in batched, multitask or multiagent</span>
<span class="sd">        settings. They are structured as ``(*prefix, &quot;_reset&quot;)`` where ``prefix`` is</span>
<span class="sd">        a (possibly empty) tuple of strings pointing to a tensordict location</span>
<span class="sd">        where a done state can be found.</span>

<span class="sd">        Keys are sorted by depth in the data tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reset_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">_replace_last</span><span class="p">(</span><span class="n">done_key</span><span class="p">,</span> <span class="s2">&quot;_reset&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">done_key</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_keys_groups</span>
            <span class="p">),</span>
            <span class="n">key</span><span class="o">=</span><span class="n">_repr_by_depth</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">reset_keys</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_filtered_reset_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns only the effective reset keys, discarding nested resets if they&#39;re not being used.&quot;&quot;&quot;</span>
        <span class="n">reset_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_keys</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_root</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">()</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">reset_key</span> <span class="ow">in</span> <span class="n">reset_keys</span><span class="p">:</span>
            <span class="n">cur_root</span> <span class="o">=</span> <span class="n">_root</span><span class="p">(</span><span class="n">reset_key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cur_root</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">)]</span> <span class="o">==</span> <span class="n">root</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_root</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reset_key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="nd">@_cache_value</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done_keys_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A list of done keys, grouped as the reset keys.</span>

<span class="sd">        This is a list of lists. The outer list has the length of reset keys, the</span>
<span class="sd">        inner lists contain the done keys (eg, done and truncated) that can</span>
<span class="sd">        be read to determine a reset when it is absent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># done keys, sorted as reset keys</span>
        <span class="n">done_keys_group</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">fds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_done_spec</span>
        <span class="k">for</span> <span class="n">done_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">done_keys</span><span class="p">:</span>
            <span class="n">root_name</span> <span class="o">=</span> <span class="n">done_key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">done_key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">()</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">fds</span><span class="p">[</span><span class="n">root_name</span><span class="p">]</span> <span class="k">if</span> <span class="n">root_name</span> <span class="k">else</span> <span class="n">fds</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
            <span class="n">roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">root_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">done_keys_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">unravel_key</span><span class="p">(</span><span class="n">root_name</span> <span class="o">+</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="n">include_nested</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">leaves_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">done_keys_group</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_select_observation_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensordict</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;observation&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">key</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">raise_if_closed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if del occurs before env has been set up, we don&#39;t want a recursion</span>
        <span class="c1"># error</span>
        <span class="k">if</span> <span class="s2">&quot;is_closed&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># a TypeError will typically be raised if the env is deleted when the program ends.</span>
                <span class="c1"># In the future, insignificant changes to the close method may change the error type.</span>
                <span class="c1"># We excplicitely assume that any error raised during closure in</span>
                <span class="c1"># __del__ will not affect the program.</span>
                <span class="k">pass</span>

<div class="viewcode-block" id="EnvBase.to"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.to">[docs]</a>    <span class="nd">@_maybe_unlock</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">DEVICE_TYPING</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnvBase</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">_make_ordinal_device</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">device</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_input_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_output_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="n">device</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span></div>

<div class="viewcode-block" id="EnvBase.fake_tensordict"><a class="viewcode-back" href="../../../reference/generated/torchrl.envs.EnvBase.html#torchrl.envs.EnvBase.fake_tensordict">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">fake_tensordict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a fake tensordict with key-value pairs that match in shape, device and dtype what can be expected during an environment rollout.&quot;&quot;&quot;</span>
        <span class="n">state_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_spec</span>
        <span class="n">observation_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observation_spec</span>
        <span class="n">action_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span><span class="p">[</span><span class="s2">&quot;full_action_spec&quot;</span><span class="p">]</span>
        <span class="c1"># instantiates reward_spec if needed</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_reward_spec</span>
        <span class="n">reward_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_reward_spec&quot;</span><span class="p">]</span>
        <span class="n">full_done_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_spec</span><span class="p">[</span><span class="s2">&quot;full_done_spec&quot;</span><span class="p">]</span>

        <span class="n">fake_obs</span> <span class="o">=</span> <span class="n">observation_spec</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="n">fake_reward</span> <span class="o">=</span> <span class="n">reward_spec</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="n">fake_done</span> <span class="o">=</span> <span class="n">full_done_spec</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="n">fake_state</span> <span class="o">=</span> <span class="n">state_spec</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="n">fake_action</span> <span class="o">=</span> <span class="n">action_spec</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">LazyStackedTensorDict</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fake_action</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">fake_input</span> <span class="o">=</span> <span class="n">fake_action</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fake_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fake_input</span> <span class="o">=</span> <span class="n">fake_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fake_action</span><span class="p">)</span>

        <span class="c1"># the input and output key may match, but the output prevails</span>
        <span class="c1"># Hence we generate the input, and override using the output</span>
        <span class="n">fake_in_out</span> <span class="o">=</span> <span class="n">fake_input</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fake_obs</span><span class="p">)</span>

        <span class="n">next_output</span> <span class="o">=</span> <span class="n">fake_obs</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">next_output</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fake_reward</span><span class="p">)</span>
        <span class="n">next_output</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fake_done</span><span class="p">)</span>
        <span class="n">fake_in_out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fake_done</span><span class="o">.</span><span class="n">clone</span><span class="p">())</span>
        <span class="k">if</span> <span class="s2">&quot;next&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fake_in_out</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">fake_in_out</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">next_output</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fake_in_out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">next_output</span><span class="p">)</span>

        <span class="n">fake_in_out</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="n">fake_in_out</span> <span class="o">=</span> <span class="n">fake_in_out</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fake_in_out</span></div></div>


<span class="k">class</span><span class="w"> </span><span class="nc">_EnvWrapper</span><span class="p">(</span><span class="n">EnvBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract environment wrapper class.</span>

<span class="sd">    Unlike EnvBase, _EnvWrapper comes with a :obj:`_build_env` private method that will be called upon instantiation.</span>
<span class="sd">    Interfaces with other libraries should be coded using _EnvWrapper.</span>

<span class="sd">    It is possible to directly query attributed from the nested environment it its name does not conflict with</span>
<span class="sd">    an attribute of the wrapper:</span>
<span class="sd">        &gt;&gt;&gt; env = SomeWrapper(...)</span>
<span class="sd">        &gt;&gt;&gt; custom_attribute0 = env._env.custom_attribute</span>
<span class="sd">        &gt;&gt;&gt; custom_attribute1 = env.custom_attribute</span>
<span class="sd">        &gt;&gt;&gt; assert custom_attribute0 is custom_attribute1  # should return True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">git_url</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">available_envs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">libname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">DEVICE_TYPING</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_done_after_reset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">spec_locked</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">allow_done_after_reset</span><span class="o">=</span><span class="n">allow_done_after_reset</span><span class="p">,</span>
            <span class="n">spec_locked</span><span class="o">=</span><span class="n">spec_locked</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`_EnvWrapper.__init__` received a non-empty args list of arguments. &quot;</span>
                <span class="s2">&quot;Make sure only keywords arguments are used when calling `super().__init__`.&quot;</span>
            <span class="p">)</span>

        <span class="n">frame_skip</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;frame_skip&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;frame_skip&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;frame_skip&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_skip</span> <span class="o">=</span> <span class="n">frame_skip</span>
        <span class="c1"># this value can be changed if frame_skip is passed during env construction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wrapper_frame_skip</span> <span class="o">=</span> <span class="n">frame_skip</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_actions_to_numpy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;convert_actions_to_numpy&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_env</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># writes the self._env attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_specs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="p">)</span>  <span class="c1"># writes the self._env attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_env</span><span class="p">()</span>  <span class="c1"># runs all the steps to have a ready-to-use env</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sync_device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sync_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_sync_device_val&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sync_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span>
            <span class="k">if</span> <span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;cuda&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sync_device_val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span>
                <span class="k">elif</span> <span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">mps</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sync_device_val</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span>
                <span class="k">elif</span> <span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;cpu&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_sync_device_val</span> <span class="o">=</span> <span class="n">_do_nothing</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sync_device_val</span> <span class="o">=</span> <span class="n">_do_nothing</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sync_device</span>
        <span class="k">return</span> <span class="n">sync_func</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_check_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span>
                <span class="n">attr</span>
            <span class="p">)</span>  <span class="c1"># make sure that appropriate exceptions are raised</span>

        <span class="k">elif</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;passing built-in private methods is &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;not permitted with type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got attribute </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="s2">&quot;_env&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">():</span>
            <span class="n">env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="s2">&quot;_env&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;env not set in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">, cannot access </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_init_env</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Runs all the necessary steps such that the environment is ready to use.</span>

<span class="sd">        This step is intended to ensure that a seed is provided to the environment (if needed) and that the environment</span>
<span class="sd">        is reset (if needed). For instance, DMControl envs require the env to be reset before being used, but Gym envs</span>
<span class="sd">        don&#39;t.</span>

<span class="sd">        Returns:</span>
<span class="sd">            the resulting seed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_build_env</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gym</span><span class="o">.</span><span class="n">Env</span><span class="p">:</span>  <span class="c1"># noqa: F821</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates an environment from the target library and stores it with the `_env` attribute.</span>

<span class="sd">        When overwritten, this function should pass all the required kwargs to the env instantiation method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_make_specs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">gym</span><span class="o">.</span><span class="n">Env</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># noqa: F821</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">raise_if_closed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Closes the contained environment if possible.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_closed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>


<span class="k">def</span><span class="w"> </span><span class="nf">make_tensordict</span><span class="p">(</span>
    <span class="n">env</span><span class="p">:</span> <span class="n">_EnvWrapper</span><span class="p">,</span>
    <span class="n">policy</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">TensorDictBase</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">TensorDictBase</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a zeroed-tensordict with fields matching those required for a full step (action selection and environment step) in the environment.</span>

<span class="sd">    Args:</span>
<span class="sd">        env (_EnvWrapper): environment defining the observation, action and reward space;</span>
<span class="sd">        policy (Callable, optional): policy corresponding to the environment.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">tensordict</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tensordict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">policy</span><span class="p">(</span><span class="n">tensordict</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tensordict</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;action&quot;</span><span class="p">,</span> <span class="n">env</span><span class="o">.</span><span class="n">action_spec</span><span class="o">.</span><span class="n">rand</span><span class="p">(),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tensordict</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">tensordict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensordict</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_sync_func</span><span class="p">(</span><span class="n">policy_device</span><span class="p">,</span> <span class="n">env_device</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
        <span class="c1"># Look for a specific device</span>
        <span class="k">if</span> <span class="n">policy_device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">policy_device</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;cuda&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">env_device</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">env_device</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;cuda&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">policy_device</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">env_device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">env_device</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;cuda&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">policy_device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">env_device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span>
    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">mps</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">mps</span><span class="o">.</span><span class="n">synchronize</span>
    <span class="k">return</span> <span class="n">_do_nothing</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_do_nothing</span><span class="p">():</span>
    <span class="k">return</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_has_dynamic_specs</span><span class="p">(</span><span class="n">spec</span><span class="p">:</span> <span class="n">Composite</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tensordict.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">_NESTED_TENSORS_AS_LISTS</span>

    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span>
        <span class="nb">any</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">is_leaf</span><span class="o">=</span><span class="n">_NESTED_TENSORS_AS_LISTS</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_tensor_to_spec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">leaf_compare</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_tensor_collection</span><span class="p">(</span><span class="n">leaf</span><span class="p">)):</span>
        <span class="n">stack</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">NonTensor</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">())</span>
        <span class="k">return</span>
    <span class="k">elif</span> <span class="n">is_non_tensor</span><span class="p">(</span><span class="n">leaf</span><span class="p">):</span>
        <span class="n">stack</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">NonTensor</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">leaf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">leaf_compare</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape_compare</span> <span class="o">=</span> <span class="n">leaf_compare</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">s0</span> <span class="k">if</span> <span class="n">s0</span> <span class="o">==</span> <span class="n">s1</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape_compare</span><span class="p">)]</span>
    <span class="n">stack</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Unbounded</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">leaf</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">leaf</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>

             </article>
             
            </div>
            <footer>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, Meta.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>


        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              
            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
         <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
         <script src="../../../_static/jquery.js"></script>
         <script src="../../../_static/underscore.js"></script>
         <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
         <script src="../../../_static/doctools.js"></script>
         <script src="../../../_static/design-tabs.js"></script>
     

  

  <script type="text/javascript" src="../../../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../../../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
     
    <script type="text/javascript">
      $(document).ready(function() {
	  var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
	  if (downloadNote.length >= 1) {
	      var tutorialUrl = $("#tutorial-type").text();
	      var githubLink = "https://github.com/pytorch/rl/blob/main/tutorials/sphinx-tutorials/"  + tutorialUrl + ".py",
		  notebookLink = $(".sphx-glr-download-jupyter").find(".download.reference")[0].href,
		  notebookDownloadPath = notebookLink.split('_downloads')[1],
		  colabLink = "https://colab.research.google.com/github/pytorch/rl/blob/gh-pages/main/_downloads" + notebookDownloadPath;

	      $(".pytorch-call-to-action-links a[data-response='Run in Google Colab']").attr("href", colabLink);
	      $(".pytorch-call-to-action-links a[data-response='View on Github']").attr("href", githubLink);
	  }

          var overwrite = function(_) {
              if ($(this).length > 0) {
                  $(this)[0].href = "https://github.com/pytorch/rl"
              }
          }
          // PC
          $(".main-menu a:contains('GitHub')").each(overwrite);
          // Mobile
          $(".main-menu a:contains('Github')").each(overwrite);
      });

      
       $(window).ready(function() {
           var original = window.sideMenus.bind;
           var startup = true;
           window.sideMenus.bind = function() {
               original();
               if (startup) {
                   $("#pytorch-right-menu a.reference.internal").each(function(i) {
                       if (this.classList.contains("not-expanded")) {
                           this.nextElementSibling.style.display = "block";
                           this.classList.remove("not-expanded");
                           this.classList.add("expanded");
                       }
                   });
                   startup = false;
               }
           };
       });
    </script>

    


  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pytorch.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
            <li><a href="https://pytorch.org/get-started">Get Started</a></li>
            <li><a href="https://pytorch.org/features">Features</a></li>
            <li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
            <li><a href="https://pytorch.org/blog/">Blog</a></li>
            <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/resources">Resources</a></li>
            <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
            <li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
            <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://pytorch.org/assets/brand-guidelines/PyTorch-Brand-Guidelines.pdf" target="_blank">Brand Guidelines</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">Stay up to date</li>
            <li><a href="https://www.facebook.com/pytorch" target="_blank">Facebook</a></li>
            <li><a href="https://twitter.com/pytorch" target="_blank">Twitter</a></li>
            <li><a href="https://www.youtube.com/pytorch" target="_blank">YouTube</a></li>
            <li><a href="https://www.linkedin.com/company/pytorch" target="_blank">LinkedIn</a></li>
          </ul>  
          </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">PyTorch Podcasts</li>
            <li><a href="https://open.spotify.com/show/6UzHKeiy368jKfQMKKvJY5" target="_blank">Spotify</a></li>
            <li><a href="https://podcasts.apple.com/us/podcast/pytorch-developer-podcast/id1566080008" target="_blank">Apple</a></li>
            <li><a href="https://www.google.com/podcasts?feed=aHR0cHM6Ly9mZWVkcy5zaW1wbGVjYXN0LmNvbS9PQjVGa0lsOA%3D%3D" target="_blank">Google</a></li>
            <li><a href="https://music.amazon.com/podcasts/7a4e6f0e-26c2-49e9-a478-41bd244197d0/PyTorch-Developer-Podcast?" target="_blank">Amazon</a></li>
          </ul>
         </div>
        </div>
        
        <div class="privacy-policy">
          <ul>
            <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/terms/" target="_blank">Terms</a></li>
            <li class="privacy-policy-links">|</li>
            <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/privacy-policy/" target="_blank">Privacy</a></li>
          </ul>
        </div>
        <div class="copyright">
        <p>Â© Copyright The Linux Foundation. The PyTorch Foundation is a project of The Linux Foundation.
          For web site terms of use, trademark policy and other policies applicable to The PyTorch Foundation please see
          <a href="https://www.linuxfoundation.org/policies/">www.linuxfoundation.org/policies/</a>. The PyTorch Foundation supports the PyTorch open source
          project, which has been established as PyTorch Project a Series of LF Projects, LLC. For policies applicable to the PyTorch Project a Series of LF Projects, LLC,
          please see <a href="https://www.lfprojects.org/policies/">www.lfprojects.org/policies/</a>.</p>
      </div>
     </div>

  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebookâ€™s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../../../_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
           <li class="resources-mobile-menu-title">
             <a>Learn</a>
           </li>
           <ul class="resources-mobile-menu-items">
             <li>
               <a href="https://pytorch.org/get-started">Get Started</a>
             </li>
             <li>
               <a href="https://pytorch.org/tutorials">Tutorials</a>
             </li>
             <li>
               <a href="https://pytorch.org/tutorials/beginner/basics/intro.html">Learn the Basics</a>
             </li>
             <li>
               <a href="https://pytorch.org/tutorials/recipes/recipes_index.html">PyTorch Recipes</a>
             </li>
             <li>
               <a href="https://pytorch.org/tutorials/beginner/introyt.html">Introduction to PyTorch - YouTube Series</a>
             </li>
           </ul>
           <li class="resources-mobile-menu-title">
             <a>Ecosystem</a>
           </li>
           <ul class="resources-mobile-menu-items">
             <li>
               <a href="https://pytorch.org/ecosystem">Tools</a>
             </li>
             <li>
               <a href="https://pytorch.org/#community-module">Community</a>
             </li>
             <li>
               <a href="https://discuss.pytorch.org/">Forums</a>
             </li>
             <li>
               <a href="https://pytorch.org/resources">Developer Resources</a>
             </li>
             <li>
               <a href="https://pytorch.org/ecosystem/contributor-awards-2023">Contributor Awards - 2024</a>
             </li>
           </ul>

           <li class="resources-mobile-menu-title">
             <a>Edge</a>
           </li>

           <ul class="resources-mobile-menu-items">
             <li>
               <a href="https://pytorch.org/edge">About PyTorch Edge</a>
             </li>
             
             <li>
               <a href="https://pytorch.org/executorch-overview">ExecuTorch</a>
             </li>
             <li>
               <a href="https://pytorch.org/executorch/stable/index.html">ExecuTorch Documentation</a>
             </li>
           </ul>

           <li class="resources-mobile-menu-title">
             <a>Docs</a>
           </li>

           <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/docs/stable/index.html">PyTorch</a>
            </li>

            <li>
              <a href="https://pytorch.org/pytorch-domains">PyTorch Domains</a>
            </li>
          </ul>

          <li class="resources-mobile-menu-title">
            <a>Blog & News</a>
          </li>
            
           <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/blog/">PyTorch Blog</a>
            </li>
            <li>
              <a href="https://pytorch.org/community-blog">Community Blog</a>
            </li>

            <li>
              <a href="https://pytorch.org/videos">Videos</a>
            </li>

            <li>
              <a href="https://pytorch.org/community-stories">Community Stories</a>
            </li>
            <li>
              <a href="https://pytorch.org/events">Events</a>
            </li>
            <li>
               <a href="https://pytorch.org/newsletter">Newsletter</a>
             </li>
          </ul>
          
          <li class="resources-mobile-menu-title">
            <a>About</a>
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/foundation">PyTorch Foundation</a>
            </li>
            <li>
              <a href="https://pytorch.org/governing-board">Governing Board</a>
            </li>
            <li>
               <a href="https://pytorch.org/credits">Cloud Credit Program</a>
            </li>
            <li>
               <a href="https://pytorch.org/tac">Technical Advisory Council</a>
            </li>
            <li>
               <a href="https://pytorch.org/staff">Staff</a>
            </li>
            <li>
               <a href="https://pytorch.org/contact-us">Contact Us</a>
            </li>
          </ul>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../../../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>