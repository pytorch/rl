


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>torchrl.data.map.tree &mdash; torchrl 0.7 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/sg_gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/sg_gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/sg_gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/sphinx-design.5ea377869091fd0449014c60fc090103.min.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','UA-117752657-2');</script>
    <!-- End Google Tag Manager -->
  

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Learn
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/get-started">
                  <span class=dropdown-title>Get Started</span>
                  <p>Run PyTorch locally or get started quickly with one of the supported cloud platforms</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials">
                  <span class="dropdown-title">Tutorials</span>
                  <p>Whats new in PyTorch tutorials</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/beginner/basics/intro.html">
                  <span class="dropdown-title">Learn the Basics</span>
                  <p>Familiarize yourself with PyTorch concepts and modules</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/recipes/recipes_index.html">
                  <span class="dropdown-title">PyTorch Recipes</span>
                  <p>Bite-size, ready-to-deploy PyTorch code examples</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tutorials/beginner/introyt.html">
                  <span class="dropdown-title">Intro to PyTorch - YouTube Series</span>
                  <p>Master PyTorch basics with our engaging YouTube tutorial series</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Ecosystem
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/ecosystem">
                  <span class="dropdown-title">Tools</span>
                  <p>Learn about the tools and frameworks in the PyTorch Ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/#community-module">
                  <span class=dropdown-title>Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="https://discuss.pytorch.org/" target="_blank">
                  <span class=dropdown-title>Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/resources">
                  <span class=dropdown-title>Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/ecosystem/contributor-awards-2024">
                  <span class="dropdown-title">Contributor Awards - 2024</span>
                  <p>Award winners announced at this year's PyTorch Conference</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Edge
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/edge">
                  <span class="dropdown-title">About PyTorch Edge</span>
                  <p>Build innovative and privacy-aware AI experiences for edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/executorch-overview">
                  <span class="dropdown-title">ExecuTorch</span>
                  <p>End-to-end solution for enabling on-device inference capabilities across mobile and edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/executorch/stable/index.html">
                  <span class="dropdown-title">ExecuTorch Docs</span>
                </a>
              </div>
            </div>  
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/docs/stable/index.html">
                  <span class="dropdown-title">PyTorch</span>
                  <p>Explore the documentation for comprehensive guidance on how to use PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/pytorch-domains">
                  <span class="dropdown-title">PyTorch Domains</span>
                  <p>Read the PyTorch Domains documentation to learn more about domain-specific libraries</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Blogs & News 
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/blog/">
                  <span class="dropdown-title">PyTorch Blog</span>
                  <p>Catch up on the latest technical news and happenings</p>
                </a>
                 <a class="nav-dropdown-item" href="https://pytorch.org/community-blog">
                  <span class="dropdown-title">Community Blog</span>
                  <p>Stories from the PyTorch ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/videos">
                  <span class="dropdown-title">Videos</span>
                  <p>Learn about the latest PyTorch tutorials, new, and more </p>
                <a class="nav-dropdown-item" href="https://pytorch.org/community-stories">
                  <span class="dropdown-title">Community Stories</span>
                  <p>Learn how our community solves real, everyday machine learning problems with PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/events">
                  <span class="dropdown-title">Events</span>
                  <p>Find events, webinars, and podcasts</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/newsletter">
                  <span class="dropdown-title">Newsletter</span>
                  <p>Stay up-to-date with the latest updates</p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                About
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://pytorch.org/foundation">
                  <span class="dropdown-title">PyTorch Foundation</span>
                  <p>Learn more about the PyTorch Foundation</p>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/governing-board">
                  <span class="dropdown-title">Governing Board</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/credits">
                  <span class="dropdown-title">Cloud Credit Program</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/tac">
                  <span class="dropdown-title">Technical Advisory Council</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/staff">
                  <span class="dropdown-title">Staff</span>
                </a>
                <a class="nav-dropdown-item" href="https://pytorch.org/contact-us">
                  <span class="dropdown-title">Contact Us</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div class="no-dropdown">
              <a href="https://pytorch.org/join" data-cta="join">
                Become a Member
              </a>
            </div>
          </li>
          <li>
           <div class="main-menu-item">
             <a href="https://github.com/pytorch/pytorch" class="github-icon">
             </a>
           </div>
          </li>
          <!--- TODO: This block adds the search icon to the nav bar. We will enable it later. 
          <li>
            <div class="main-menu-item">
             <a href="https://github.com/pytorch/pytorch" class="search-icon">
             </a>
            </div>
          </li>
          --->
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            
    <div class="version">
      <a href="../../../../../versions.html"><span style="font-size:110%">0.7 &#x25BC</span></a>
    </div>
    


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          </div>

          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/getting-started-0.html">Get started with Environments, TED and transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/getting-started-1.html">Get started with TorchRLâ€™s modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/getting-started-2.html">Getting started with model optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/getting-started-3.html">Get started with data collection and storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/getting-started-4.html">Get started with logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/getting-started-5.html">Get started with your own first training loop</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/coding_ppo.html">Reinforcement Learning (PPO) with TorchRL Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/pendulum.html">Pendulum: Writing your environment and transforms with TorchRL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/torchrl_demo.html">Introduction to TorchRL</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/multiagent_ppo.html">Multi-Agent Reinforcement Learning (PPO) with TorchRL Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/torchrl_envs.html">TorchRL envs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/pretrained_models.html">Using pretrained models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/dqn_with_rnn.html">Recurrent DQN: Training recurrent policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/rb_tutorial.html">Using Replay Buffers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/export.html">Exporting TorchRL modules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/multiagent_competitive_ddpg.html">Competitive Multi-Agent Reinforcement Learning (DDPG) with TorchRL Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/multi_task.html">Task-specific policy in multi-task environments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/coding_ddpg.html">TorchRL objectives: Coding a DDPG loss</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/coding_dqn.html">TorchRL trainer: A DQN example</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/index.html">API Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/knowledge_base.html">Knowledge Base</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../../../../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="../../../index.html">Module code</a> &gt;</li>
        
      <li>torchrl.data.map.tree</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        
    
    
          <!-- Google Tag Manager (noscript) -->
          <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=UA-117752657-2"
          height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
          <!-- End Google Tag Manager (noscript) -->
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <h1>Source code for torchrl.data.map.tree</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Meta Platforms, Inc. and affiliates.</span>
<span class="c1">#</span>
<span class="c1"># This source code is licensed under the MIT license found in the</span>
<span class="c1"># LICENSE file in the root directory of this source tree.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">weakref</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tensordict</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">merge_tensordicts</span><span class="p">,</span>
    <span class="n">NestedKey</span><span class="p">,</span>
    <span class="n">TensorClass</span><span class="p">,</span>
    <span class="n">TensorDict</span><span class="p">,</span>
    <span class="n">TensorDictBase</span><span class="p">,</span>
    <span class="n">unravel_key</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.data.map.tdstorage</span><span class="w"> </span><span class="kn">import</span> <span class="n">TensorDictMap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.data.map.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_plot_plotly_box</span><span class="p">,</span> <span class="n">_plot_plotly_tree</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.data.replay_buffers.storages</span><span class="w"> </span><span class="kn">import</span> <span class="n">ListStorage</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.data.tensor_specs</span><span class="w"> </span><span class="kn">import</span> <span class="n">Composite</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">torchrl.envs.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">EnvBase</span>


<div class="viewcode-block" id="Tree"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">Tree</span><span class="p">(</span><span class="n">TensorClass</span><span class="p">[</span><span class="s2">&quot;nocast&quot;</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Representation of a single MCTS (Monte Carlo Tree Search) Tree.</span>

<span class="sd">    This class encapsulates the data and behavior of a tree node in an MCTS algorithm.</span>
<span class="sd">    It includes attributes for storing information about the node, such as its children,</span>
<span class="sd">    visit count, and rollout data. Methods are provided for traversing the tree,</span>
<span class="sd">    computing statistics, and visualizing the tree structure.</span>

<span class="sd">    It is somewhat indistinguishable from a node or a vertex - we use the term &quot;Tree&quot; when talking about</span>
<span class="sd">    a node with children, &quot;node&quot; or &quot;vertex&quot; when talking about a place in the tree where a branching occurs.</span>
<span class="sd">    A node in the tree is defined primarily by its ``hash`` value. Usually, a ``hash`` is determined by a unique</span>
<span class="sd">    combination of state (or observation) and action. If one observation (found in the ``node`` attribute) has more than</span>
<span class="sd">    one action associated, each branch will be stored in the ``subtree`` attribute as a stack of ``Tree`` instances.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        count (int): The number of visits to this node.</span>
<span class="sd">        index (torch.Tensor): Indices of the child nodes in the data map.</span>
<span class="sd">        hash (torch.Tensor): A hash value for this node.</span>
<span class="sd">            It may be the case that ``hash`` is ``None`` in the specific case where the root of the tree</span>
<span class="sd">            has more than one action associated. In that case, each subtree branch will have a different action</span>
<span class="sd">            associated and a hash correspoding to the ``(observation, action)`` pair.</span>
<span class="sd">        node_id (int): A unique identifier for this node.</span>
<span class="sd">        rollout (TensorDict): Rollout data following the observation encoded in this node, in a TED format.</span>
<span class="sd">            If there are multiple actions taken at this node, subtrees are stored in the corresponding</span>
<span class="sd">            entry. Rollouts can be reconstructed using the :meth:`rollout_from_path` method.</span>
<span class="sd">        node (TensorDict): Data defining this node (e.g., observations) before the next branching.</span>
<span class="sd">            Entries usually matches the ``in_keys`` in ``MCTSForest.node_map``.</span>
<span class="sd">        subtree (Tree): A stack of subtrees produced when actions are taken.</span>
<span class="sd">        num_children (int): The number of child nodes (read-only).</span>
<span class="sd">        is_terminal (bool): whether the tree has children nodes (read-only).</span>
<span class="sd">            If the tree is compact, ``is_terminal == True`` means that there are more than one child node in</span>
<span class="sd">            ``self.subtree``.</span>

<span class="sd">    Methods:</span>
<span class="sd">        __contains__: Whether another tree can be found in the tree.</span>
<span class="sd">        vertices: Returns a dictionary containing all vertices in the tree. Keys must be paths, ids or hashes.</span>
<span class="sd">        num_vertices: Returns the total number of vertices in the tree, with or without duplicates.</span>
<span class="sd">        edges: Returns a list of edges in the tree.</span>
<span class="sd">        valid_paths: Yields all valid paths in the tree.</span>
<span class="sd">        max_length: Returns the maximum length of any path in the tree.</span>
<span class="sd">        rollout_from_path: Reconstructs a rollout from a given path.</span>
<span class="sd">        plot: Visualizes the tree using a specified backend and figure type.</span>
<span class="sd">        get_node_by_id: returns the vertex given by its id in the tree.</span>
<span class="sd">        get_node_by_hash: returns the vertex given by its hash in the forest.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">wins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">index</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># The hash is None if the node has more than one action associated</span>
    <span class="nb">hash</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">node_id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># rollout following the observation encoded in node, in a TorchRL (TED) format</span>
    <span class="n">rollout</span><span class="p">:</span> <span class="n">TensorDict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># The data specifying the node (typically an observation or a set of observations)</span>
    <span class="n">node_data</span><span class="p">:</span> <span class="n">TensorDict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Stack of subtrees. A subtree is produced when an action is taken.</span>
    <span class="n">subtree</span><span class="p">:</span> <span class="s2">&quot;Tree&quot;</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># weakrefs to the parent(s) of the node</span>
    <span class="n">_parent</span><span class="p">:</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Specs: contains information such as action or observation keys and spaces.</span>
    <span class="c1">#  If present, they should be structured like env specs are:</span>
    <span class="c1">#  Composite(input_spec=Composite(full_state_spec=..., full_action_spec=...),</span>
    <span class="c1">#            output_spec=Composite(full_observation_spec=..., full_reward_spec=..., full_done_spec=...))</span>
    <span class="c1">#  where every leaf component is optional.</span>
    <span class="n">specs</span><span class="p">:</span> <span class="n">Composite</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Tree.make_node"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.make_node">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_node</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">specs</span><span class="p">:</span> <span class="n">Composite</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tree</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new node given some data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;next&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">rollout</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">rollout</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="n">rollout</span> <span class="o">=</span> <span class="n">rollout</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">subtree</span> <span class="o">=</span> <span class="n">TensorDict</span><span class="o">.</span><span class="n">lazy_stack</span><span class="p">([</span><span class="bp">cls</span><span class="o">.</span><span class="n">make_node</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rollout</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">subtree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">device</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">count</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(()),</span>
            <span class="n">wins</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(()),</span>
            <span class="n">node_data</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="s2">&quot;action&quot;</span><span class="p">,</span> <span class="s2">&quot;next&quot;</span><span class="p">),</span>
            <span class="n">rollout</span><span class="o">=</span><span class="n">rollout</span><span class="p">,</span>
            <span class="n">subtree</span><span class="o">=</span><span class="n">subtree</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="c1"># Specs</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_observation_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The observation spec of the tree.</span>

<span class="sd">        This is an alias for `Tree.specs[&#39;output_spec&#39;, &#39;full_observation_spec&#39;]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s2">&quot;output_spec&quot;</span><span class="p">,</span> <span class="s2">&quot;full_observation_spec&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_reward_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The reward spec of the tree.</span>

<span class="sd">        This is an alias for `Tree.specs[&#39;output_spec&#39;, &#39;full_reward_spec&#39;]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s2">&quot;output_spec&quot;</span><span class="p">,</span> <span class="s2">&quot;full_reward_spec&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_done_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The done spec of the tree.</span>

<span class="sd">        This is an alias for `Tree.specs[&#39;output_spec&#39;, &#39;full_done_spec&#39;]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s2">&quot;output_spec&quot;</span><span class="p">,</span> <span class="s2">&quot;full_done_spec&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_state_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The state spec of the tree.</span>

<span class="sd">        This is an alias for `Tree.specs[&#39;input_spec&#39;, &#39;full_state_spec&#39;]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s2">&quot;input_spec&quot;</span><span class="p">,</span> <span class="s2">&quot;full_state_spec&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_action_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The action spec of the tree.</span>

<span class="sd">        This is an alias for `Tree.specs[&#39;input_spec&#39;, &#39;full_action_spec&#39;]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">specs</span><span class="p">[</span><span class="s2">&quot;input_spec&quot;</span><span class="p">,</span> <span class="s2">&quot;full_action_spec&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">selected_actions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a tensor containing all the selected actions branching out from this node.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtree</span><span class="o">.</span><span class="n">rollout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="s2">&quot;action&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">prev_action</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The action undertaken just before this node&#39;s observation was generated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tensor, tensordict or None if the node has no parent.</span>

<span class="sd">        .. seealso:: This will be equal to :class:`~torchrl.data.Tree.branching_action` whenever the rollout data contains a single step.</span>

<span class="sd">        .. seealso:: :class:`All actions associated with a given node (or observation) in the tree &lt;~torchrl.data.Tree.selected_action&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;action&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">branching_action</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the action that branched out to this particular node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a tensor, tensordict or None if the node has no parent.</span>

<span class="sd">        .. seealso:: This will be equal to :class:`~torchrl.data.Tree.prev_action` whenever the rollout data contains a single step.</span>

<span class="sd">        .. seealso:: :class:`All actions associated with a given node (or observation) in the tree &lt;~torchrl.data.Tree.selected_action&gt;`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">][</span><span class="s2">&quot;action&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">node_observation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the observation associated with this particular node.</span>

<span class="sd">        This is the observation (or bag of observations) that defines the node before a branching occurs.</span>
<span class="sd">        If the node contains a :meth:`rollout` attribute, the node observation is typically identical to the</span>
<span class="sd">        observation resulting from the last action undertaken, i.e., ``node.rollout[..., -1][&quot;next&quot;, &quot;observation&quot;]``.</span>

<span class="sd">        If more than one observation key is associated with the tree specs, a :class:`~tensordict.TensorDict` instance</span>
<span class="sd">        is returned instead.</span>

<span class="sd">        For a more consistent representation, see :attr:`~.node_observations`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: implement specs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_data</span><span class="p">[</span><span class="s2">&quot;observation&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">node_observations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="n">TensorDictBase</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the observations associated with this particular node in a TensorDict format.</span>

<span class="sd">        This is the observation (or bag of observations) that defines the node before a branching occurs.</span>
<span class="sd">        If the node contains a :meth:`rollout` attribute, the node observation is typically identical to the</span>
<span class="sd">        observation resulting from the last action undertaken, i.e., ``node.rollout[..., -1][&quot;next&quot;, &quot;observation&quot;]``.</span>

<span class="sd">        If more than one observation key is associated with the tree specs, a :class:`~tensordict.TensorDict` instance</span>
<span class="sd">        is returned instead.</span>

<span class="sd">        For a more consistent representation, see :attr:`~.node_observations`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: implement specs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_data</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;observation&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">visits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of visits associated with this particular node.</span>

<span class="sd">        This is an alias for the :attr:`~.count` attribute.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>

    <span class="nd">@visits</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">visits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;subtree&quot;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wr</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tensordict</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">wr</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">value</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="n">wr</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tree</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The parent of the node.</span>

<span class="sd">        If the node has a parent and this object is still present in the python workspace, it will be returned by this</span>
<span class="sd">        property.</span>

<span class="sd">        For re-branching trees, this property may return a stack of trees where every index of the stack corresponds to</span>
<span class="sd">        a different parent.</span>

<span class="sd">        .. note:: the ``parent`` attribute will match in content but not in identity: the tensorclass object is recustructed</span>
<span class="sd">            using the same tensors (i.e., tensors that point to the same memory locations).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A ``Tree`` containing the parent data or ``None`` if the parent data is out of scope or the node is the root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check that all parents match</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent</span><span class="p">]</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">maybe_flatten_list</span><span class="p">(</span><span class="n">maybe_nested_list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maybe_nested_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">maybe_nested_list</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">p</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">maybe_nested_list</span><span class="p">()</span>

            <span class="n">parent_result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
                <span class="n">local_result</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">maybe_flatten_list</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="n">local_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">local_result</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="k">elif</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">local_result</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">local_result</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                            <span class="n">local_result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">local_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">local_result</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">local_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># replicate logic at macro level</span>
                <span class="k">if</span> <span class="n">parent_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parent_result</span> <span class="o">=</span> <span class="n">local_result</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">local_result</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">local_result</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">local_result</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parent_result</span>
                        <span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">local_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">local_result</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent_result</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">parent_result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">local_result</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">parent_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent_result</span><span class="p">,</span> <span class="o">*</span><span class="n">local_result</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent_result</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">TensorDict</span><span class="o">.</span><span class="n">lazy_stack</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_from_tensordict</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">parent_result</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_tensordict</span><span class="p">(</span><span class="n">parent_result</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_children</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of children of this node.</span>

<span class="sd">        Equates to the number of elements in the ``self.subtree`` stack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtree</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the tree has no children nodes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="s2">&quot;done&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># If there is no rollout, there is no preceding data - either this is a root or it&#39;s a floating node.</span>
        <span class="c1"># In either case, we assume that the node is not terminal.</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Tree.fully_expanded"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.fully_expanded">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">fully_expanded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">EnvBase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns True if the number of children is equal to the environment cardinality.&quot;&quot;&quot;</span>
        <span class="n">cardinality</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">cardinality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_data</span><span class="p">)</span>
        <span class="n">num_actions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_children</span>
        <span class="k">return</span> <span class="n">cardinality</span> <span class="o">==</span> <span class="n">num_actions</span></div>

<div class="viewcode-block" id="Tree.get_vertex_by_id"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.get_vertex_by_id">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_vertex_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tree</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Goes through the tree and returns the node corresponding the given id.&quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">node_id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tree</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">q</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtree</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node with id </span><span class="si">{</span><span class="nb">id</span><span class="si">}</span><span class="s2"> not found.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.get_vertex_by_hash"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.get_vertex_by_hash">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_vertex_by_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tree</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Goes through the tree and returns the node corresponding the given hash.&quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tree</span>
            <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">q</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtree</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node with hash </span><span class="si">{</span><span class="nb">hash</span><span class="si">}</span><span class="s2"> not found.&quot;</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="nb">hash</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">hash</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">vertex</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Tree.vertices"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.vertices">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vertices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">key_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;hash&quot;</span><span class="p">,</span> <span class="s2">&quot;path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;hash&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Tree</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a map containing the vertices of the Tree.</span>

<span class="sd">        Keyword args:</span>
<span class="sd">            key_type (Literal[&quot;id&quot;, &quot;hash&quot;, &quot;path&quot;], optional): Specifies the type of key to use for the vertices.</span>

<span class="sd">                - &quot;id&quot;: Use the vertex ID as the key.</span>
<span class="sd">                - &quot;hash&quot;: Use a hash of the vertex as the key.</span>
<span class="sd">                - &quot;path&quot;: Use the path to the vertex as the key. This may lead to a dictionary with a longer length than</span>
<span class="sd">                    when ``&quot;id&quot;`` or ``&quot;hash&quot;`` are used as the same node may be part of multiple trajectories.</span>
<span class="sd">                    Defaults to ``&quot;hash&quot;``.</span>

<span class="sd">                Defaults to an empty string, which may imply a default behavior.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict[int | Tuple[int], Tree]: A dictionary mapping keys to Tree vertices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">cur_path</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_path</span><span class="p">))</span>
        <span class="n">use_hash</span> <span class="o">=</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;hash&quot;</span>
        <span class="n">use_id</span> <span class="o">=</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;id&quot;</span>
        <span class="n">use_path</span> <span class="o">=</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s2">&quot;path&quot;</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">tree</span><span class="p">,</span> <span class="n">cur_path</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">hash</span>
            <span class="k">if</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">memo</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_path</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">memo</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_path</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">cur_path</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span>
            <span class="k">elif</span> <span class="n">use_id</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span>
            <span class="k">elif</span> <span class="n">use_hash</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;key_type must be either &#39;hash&#39;, &#39;id&#39; or &#39;path&#39;. Got </span><span class="si">{</span><span class="n">key_type</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">num_children</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">cur_path_tree</span> <span class="o">=</span> <span class="n">cur_path</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tree</span><span class="o">.</span><span class="n">subtree</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cur_path_tree</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Tree.num_vertices"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.num_vertices">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">num_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">count_repeat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of unique vertices in the Tree.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            count_repeat (bool, optional): Determines whether to count repeated</span>
<span class="sd">                vertices.</span>

<span class="sd">                - If ``False``, counts each unique vertex only once.</span>

<span class="sd">                - If ``True``, counts vertices multiple times if they appear in different paths.</span>
<span class="sd">                Defaults to ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The number of unique vertices in the Tree.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">v</span><span class="o">.</span><span class="n">node_id</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(</span>
                    <span class="n">key_type</span><span class="o">=</span><span class="s2">&quot;hash&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">count_repeat</span> <span class="k">else</span> <span class="s2">&quot;path&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Tree.edges"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.edges">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves a list of edges in the tree.</span>

<span class="sd">        Each edge is represented as a tuple of two node IDs: the parent node ID and the child node ID.</span>
<span class="sd">        The tree is traversed using Breadth-First Search (BFS) to ensure all edges are visited.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples, where each tuple contains a parent node ID and a child node ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span>
        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">tree</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">num_children</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">node_id</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">node_id</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">parent</span><span class="p">,</span> <span class="n">node_id</span><span class="p">))</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">node_id</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Tree.valid_paths"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.valid_paths">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">valid_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generates all valid paths in the tree.</span>

<span class="sd">        A valid path is a sequence of child indices that starts at the root node and ends at a leaf node.</span>
<span class="sd">        Each path is represented as a tuple of integers, where each integer corresponds to the index of a child node.</span>

<span class="sd">        Yields:</span>
<span class="sd">            tuple: A valid path in the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize a queue with the current tree node and an empty path</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">cur_path</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_path</span><span class="p">))</span>
        <span class="c1"># Perform BFS traversal of the tree</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="c1"># Dequeue the next tree node and its current path</span>
            <span class="n">tree</span><span class="p">,</span> <span class="n">cur_path</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="c1"># Get the number of child nodes</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">num_children</span><span class="p">)</span>
            <span class="c1"># If this is a leaf node, yield the current path</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">cur_path</span>
            <span class="c1"># Iterate over the child nodes</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">cur_path_tree</span> <span class="o">=</span> <span class="n">cur_path</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tree</span><span class="o">.</span><span class="n">subtree</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cur_path_tree</span><span class="p">))</span></div>

<div class="viewcode-block" id="Tree.max_length"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.max_length">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">max_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the maximum length of all valid paths in the tree.</span>

<span class="sd">        The length of a path is defined as the number of nodes in the path.</span>
<span class="sd">        If the tree is empty, returns 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The maximum length of all valid paths in the tree.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_paths</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="o">*</span><span class="n">lengths</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.rollout_from_path"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.rollout_from_path">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">rollout_from_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves the rollout data along a given path in the tree.</span>

<span class="sd">        The rollout data is concatenated along the last dimension (dim=-1) for each node in the path.</span>
<span class="sd">        If no rollout data is found along the path, returns ``None``.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: A tuple of integers representing the path in the tree.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The concatenated rollout data along the path, or None if no data is found.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rollout</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">rollouts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rollouts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">rollout</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rollouts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rollouts</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">rollouts</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_label</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">tree</span><span class="p">:</span> <span class="s2">&quot;Tree&quot;</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;hash&quot;</span><span class="p">:</span>
                <span class="nb">hash</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">hash</span>
                <span class="k">if</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">v</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;hash=</span><span class="si">{</span><span class="nb">hash</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">elif</span> <span class="n">root</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">=None&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">rollout</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.plot"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.Tree.html#torchrl.data.Tree.plot">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">Tree</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;plotly&quot;</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;tree&quot;</span><span class="p">,</span>
        <span class="n">info</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">make_labels</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots a visualization of the tree using the specified backend and figure type.</span>

<span class="sd">        Args:</span>
<span class="sd">            backend: The plotting backend to use. Currently only supports &#39;plotly&#39;.</span>
<span class="sd">            figure: The type of figure to plot. Can be either &#39;tree&#39; or &#39;box&#39;.</span>
<span class="sd">            info: A list of additional information to include in the plot (not currently used).</span>
<span class="sd">            make_labels: An optional function to generate custom labels for the plot.</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError: If an unsupported backend or figure type is specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;plotly&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">figure</span> <span class="o">==</span> <span class="s2">&quot;box&quot;</span><span class="p">:</span>
                <span class="n">_plot_plotly_box</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">figure</span> <span class="o">==</span> <span class="s2">&quot;tree&quot;</span><span class="p">:</span>
                <span class="n">_plot_plotly_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">make_labels</span><span class="o">=</span><span class="n">make_labels</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unknown plotting backend </span><span class="si">{</span><span class="n">backend</span><span class="si">}</span><span class="s2"> with figure </span><span class="si">{</span><span class="n">figure</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="MCTSForest"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.MCTSForest.html#torchrl.data.MCTSForest">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">MCTSForest</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A collection of MCTS trees.</span>

<span class="sd">    .. warning:: This class is currently under active development. Expect frequent API changes.</span>

<span class="sd">    The class is aimed at storing rollouts in a storage, and produce trees based on a given root</span>
<span class="sd">    in that dataset.</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        data_map (TensorDictMap, optional): the storage to use to store the data</span>
<span class="sd">            (observation, reward, states etc). If not provided, it is lazily</span>
<span class="sd">            initialized using :meth:`~torchrl.data.map.tdstorage.TensorDictMap.from_tensordict_pair`</span>
<span class="sd">            using the list of :attr:`observation_keys` and :attr:`action_keys` as ``in_keys``.</span>
<span class="sd">        node_map (TensorDictMap, optional): a map from the observation space to the index space.</span>
<span class="sd">            Internally, the node map is used to gather all possible branches coming out of</span>
<span class="sd">            a given node. For example, if an observation has two associated actions and outcomes</span>
<span class="sd">            in the data map, then the :attr:`node_map` will return a data structure containing the</span>
<span class="sd">            two indices in the :attr:`data_map` that correspond to these two outcomes.</span>
<span class="sd">            If not provided, it is lazily initialized using</span>
<span class="sd">            :meth:`~torchrl.data.map.tdstorage.TensorDictMap.from_tensordict_pair` using the list of</span>
<span class="sd">            :attr:`observation_keys` as ``in_keys`` and the :class:`~torchrl.data.QueryModule` as</span>
<span class="sd">            ``out_keys``.</span>
<span class="sd">        max_size (int, optional): the size of the maps.</span>
<span class="sd">            If not provided, defaults to ``data_map.max_size`` if this can be found, then</span>
<span class="sd">            ``node_map.max_size``. If none of these are provided, defaults to `1000`.</span>
<span class="sd">        done_keys (list of NestedKey, optional): the done keys of the environment. If not provided,</span>
<span class="sd">            defaults to ``(&quot;done&quot;, &quot;terminated&quot;, &quot;truncated&quot;)``.</span>
<span class="sd">            The :meth:`get_keys_from_env` can be used to automatically determine the keys.</span>
<span class="sd">        action_keys (list of NestedKey, optional): the action keys of the environment. If not provided,</span>
<span class="sd">            defaults to ``(&quot;action&quot;,)``.</span>
<span class="sd">            The :meth:`get_keys_from_env` can be used to automatically determine the keys.</span>
<span class="sd">        reward_keys (list of NestedKey, optional): the reward keys of the environment. If not provided,</span>
<span class="sd">            defaults to ``(&quot;reward&quot;,)``.</span>
<span class="sd">            The :meth:`get_keys_from_env` can be used to automatically determine the keys.</span>
<span class="sd">        observation_keys (list of NestedKey, optional): the observation keys of the environment. If not provided,</span>
<span class="sd">            defaults to ``(&quot;observation&quot;,)``.</span>
<span class="sd">            The :meth:`get_keys_from_env` can be used to automatically determine the keys.</span>
<span class="sd">        excluded_keys (list of NestedKey, optional): a list of keys to exclude from the data storage.</span>
<span class="sd">        consolidated (bool, optional): if ``True``, the data_map storage will be consolidated on disk.</span>
<span class="sd">            Defaults to ``False``.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from torchrl.envs import GymEnv</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; from tensordict import TensorDict, LazyStackedTensorDict</span>
<span class="sd">        &gt;&gt;&gt; from torchrl.data import TensorDictMap, ListStorage</span>
<span class="sd">        &gt;&gt;&gt; from torchrl.data.map.tree import MCTSForest</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; from torchrl.envs import PendulumEnv, CatTensors, UnsqueezeTransform, StepCounter</span>
<span class="sd">        &gt;&gt;&gt; # Create the MCTS Forest</span>
<span class="sd">        &gt;&gt;&gt; forest = MCTSForest()</span>
<span class="sd">        &gt;&gt;&gt; # Create an environment. We&#39;re using a stateless env to be able to query it at any given state (like an oracle)</span>
<span class="sd">        &gt;&gt;&gt; env = PendulumEnv()</span>
<span class="sd">        &gt;&gt;&gt; obs_keys = list(env.observation_spec.keys(True, True))</span>
<span class="sd">        &gt;&gt;&gt; state_keys = set(env.full_state_spec.keys(True, True)) - set(obs_keys)</span>
<span class="sd">        &gt;&gt;&gt; # Appending transforms to get an &quot;observation&quot; key that concatenates the observations together</span>
<span class="sd">        &gt;&gt;&gt; env = env.append_transform(</span>
<span class="sd">        ...     UnsqueezeTransform(</span>
<span class="sd">        ...         in_keys=obs_keys,</span>
<span class="sd">        ...         out_keys=[(&quot;unsqueeze&quot;, key) for key in obs_keys],</span>
<span class="sd">        ...         dim=-1</span>
<span class="sd">        ...     )</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; env = env.append_transform(</span>
<span class="sd">        ...     CatTensors([(&quot;unsqueeze&quot;, key) for key in obs_keys], &quot;observation&quot;)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; env = env.append_transform(StepCounter())</span>
<span class="sd">        &gt;&gt;&gt; env.set_seed(0)</span>
<span class="sd">        &gt;&gt;&gt; # Get a reset state, then make a rollout out of it</span>
<span class="sd">        &gt;&gt;&gt; reset_state = env.reset()</span>
<span class="sd">        &gt;&gt;&gt; rollout0 = env.rollout(6, auto_reset=False, tensordict=reset_state.clone())</span>
<span class="sd">        &gt;&gt;&gt; # Append the rollout to the forest. We&#39;re removing the state entries for clarity</span>
<span class="sd">        &gt;&gt;&gt; rollout0 = rollout0.copy()</span>
<span class="sd">        &gt;&gt;&gt; rollout0.exclude(*state_keys, inplace=True).get(&quot;next&quot;).exclude(*state_keys, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; forest.extend(rollout0)</span>
<span class="sd">        &gt;&gt;&gt; # The forest should have 6 elements (the length of the rollout)</span>
<span class="sd">        &gt;&gt;&gt; assert len(forest) == 6</span>
<span class="sd">        &gt;&gt;&gt; # Let&#39;s make another rollout from the same reset state</span>
<span class="sd">        &gt;&gt;&gt; rollout1 = env.rollout(6, auto_reset=False, tensordict=reset_state.clone())</span>
<span class="sd">        &gt;&gt;&gt; rollout1.exclude(*state_keys, inplace=True).get(&quot;next&quot;).exclude(*state_keys, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; forest.extend(rollout1)</span>
<span class="sd">        &gt;&gt;&gt; assert len(forest) == 12</span>
<span class="sd">        &gt;&gt;&gt; # Let&#39;s make another final rollout from an intermediate step in the second rollout</span>
<span class="sd">        &gt;&gt;&gt; rollout1b = env.rollout(6, auto_reset=False, tensordict=rollout1[3].exclude(&quot;next&quot;))</span>
<span class="sd">        &gt;&gt;&gt; rollout1b.exclude(*state_keys, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; rollout1b.get(&quot;next&quot;).exclude(*state_keys, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; forest.extend(rollout1b)</span>
<span class="sd">        &gt;&gt;&gt; assert len(forest) == 18</span>
<span class="sd">        &gt;&gt;&gt; # Since we have 2 rollouts starting at the same state, our tree should have two</span>
<span class="sd">        &gt;&gt;&gt; #  branches if we produce it from the reset entry. Take the state, and call `get_tree`:</span>
<span class="sd">        &gt;&gt;&gt; r = rollout0[0]</span>
<span class="sd">        &gt;&gt;&gt; # Let&#39;s get the compact tree that follows the initial reset. A compact tree is</span>
<span class="sd">        &gt;&gt;&gt; #  a tree where nodes that have a single child are collapsed.</span>
<span class="sd">        &gt;&gt;&gt; tree = forest.get_tree(r)</span>
<span class="sd">        &gt;&gt;&gt; print(tree.max_length())</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; print(list(tree.valid_paths()))</span>
<span class="sd">        [(0,), (1, 0), (1, 1)]</span>
<span class="sd">        &gt;&gt;&gt; from tensordict import assert_close</span>
<span class="sd">        &gt;&gt;&gt; # We can manually rebuild the tree</span>
<span class="sd">        &gt;&gt;&gt; assert_close(</span>
<span class="sd">        ...     rollout1,</span>
<span class="sd">        ...     torch.cat([tree.subtree[1].rollout, tree.subtree[1].subtree[0].rollout]),</span>
<span class="sd">        ...     intersection=True,</span>
<span class="sd">        ... )</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; # Or we can rebuild it using the dedicated method</span>
<span class="sd">        &gt;&gt;&gt; assert_close(</span>
<span class="sd">        ...     rollout1,</span>
<span class="sd">        ...     tree.rollout_from_path((1, 0)),</span>
<span class="sd">        ...     intersection=True,</span>
<span class="sd">        ... )</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; tree.plot()</span>
<span class="sd">        &gt;&gt;&gt; tree = forest.get_tree(r, compact=False)</span>
<span class="sd">        &gt;&gt;&gt; print(tree.max_length())</span>
<span class="sd">        9</span>
<span class="sd">        &gt;&gt;&gt; print(list(tree.valid_paths()))</span>
<span class="sd">        [(0, 0, 0, 0, 0, 0), (1, 0, 0, 0, 0, 0), (1, 0, 0, 1, 0, 0, 0, 0, 0)]</span>
<span class="sd">        &gt;&gt;&gt; assert_close(</span>
<span class="sd">        ...     rollout1,</span>
<span class="sd">        ...     tree.rollout_from_path((1, 0, 0, 0, 0, 0)),</span>
<span class="sd">        ...     intersection=True,</span>
<span class="sd">        ... )</span>
<span class="sd">        True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">data_map</span><span class="p">:</span> <span class="n">TensorDictMap</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">node_map</span><span class="p">:</span> <span class="n">TensorDictMap</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">done_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reward_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">observation_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">action_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">excluded_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">consolidated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_map</span> <span class="o">=</span> <span class="n">data_map</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span> <span class="o">=</span> <span class="n">node_map</span>

        <span class="k">if</span> <span class="n">max_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="n">data_map</span><span class="o">.</span><span class="n">max_size</span>
                <span class="k">if</span> <span class="n">max_size</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node_map</span><span class="p">,</span> <span class="s2">&quot;max_size&quot;</span><span class="p">,</span> <span class="n">max_size</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Conflicting max_size: got data_map.max_size=</span><span class="si">{</span><span class="n">data_map</span><span class="o">.</span><span class="n">max_size</span><span class="si">}</span><span class="s2"> and node_map.max_size=</span><span class="si">{</span><span class="n">node_map</span><span class="o">.</span><span class="n">max_size</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">node_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="n">node_map</span><span class="o">.</span><span class="n">max_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">data_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_size</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="n">data_map</span><span class="p">,</span> <span class="s2">&quot;max_size&quot;</span><span class="p">,</span> <span class="n">max_size</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Conflicting max_size: got data_map.max_size=</span><span class="si">{</span><span class="n">data_map</span><span class="o">.</span><span class="n">max_size</span><span class="si">}</span><span class="s2"> and max_size=</span><span class="si">{</span><span class="n">max_size</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">node_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_size</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="n">node_map</span><span class="p">,</span> <span class="s2">&quot;max_size&quot;</span><span class="p">,</span> <span class="n">max_size</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Conflicting max_size: got node_map.max_size=</span><span class="si">{</span><span class="n">node_map</span><span class="o">.</span><span class="n">max_size</span><span class="si">}</span><span class="s2"> and max_size=</span><span class="si">{</span><span class="n">max_size</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="o">=</span> <span class="n">max_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">done_keys</span> <span class="o">=</span> <span class="n">done_keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">action_keys</span> <span class="o">=</span> <span class="n">action_keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reward_keys</span> <span class="o">=</span> <span class="n">reward_keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observation_keys</span> <span class="o">=</span> <span class="n">observation_keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excluded_keys</span> <span class="o">=</span> <span class="n">excluded_keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consolidated</span> <span class="o">=</span> <span class="n">consolidated</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Done Keys.</span>

<span class="sd">        Returns the keys used to indicate that an episode has ended.</span>
<span class="sd">        The default done keys are &quot;done&quot;, &quot;terminated&quot;, and &quot;truncated&quot;. These keys can be</span>
<span class="sd">        used in the environment&#39;s output to signal the end of an episode.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of strings representing the done keys.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">done_keys</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_done_keys&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">done_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_done_keys</span> <span class="o">=</span> <span class="n">done_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;done&quot;</span><span class="p">,</span> <span class="s2">&quot;terminated&quot;</span><span class="p">,</span> <span class="s2">&quot;truncated&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">done_keys</span>

    <span class="nd">@done_keys</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_done_keys</span> <span class="o">=</span> <span class="n">_make_list_of_nestedkeys</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;done_keys&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reward_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reward Keys.</span>

<span class="sd">        Returns the keys used to retrieve rewards from the environment&#39;s output.</span>
<span class="sd">        The default reward key is &quot;reward&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of strings or tuples representing the reward keys.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reward_keys</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_reward_keys&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reward_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reward_keys</span> <span class="o">=</span> <span class="n">reward_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;reward&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">reward_keys</span>

    <span class="nd">@reward_keys</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reward_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reward_keys</span> <span class="o">=</span> <span class="n">_make_list_of_nestedkeys</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;reward_keys&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">action_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Action Keys.</span>

<span class="sd">        Returns the keys used to retrieve actions from the environment&#39;s input.</span>
<span class="sd">        The default action key is &quot;action&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of strings or tuples representing the action keys.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">action_keys</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_action_keys&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_action_keys</span> <span class="o">=</span> <span class="n">action_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;action&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">action_keys</span>

    <span class="nd">@action_keys</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">action_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_action_keys</span> <span class="o">=</span> <span class="n">_make_list_of_nestedkeys</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;action_keys&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observation_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Observation Keys.</span>

<span class="sd">        Returns the keys used to retrieve observations from the environment&#39;s output.</span>
<span class="sd">        The default observation key is &quot;observation&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of strings or tuples representing the observation keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">observation_keys</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_observation_keys&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">observation_keys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_observation_keys</span> <span class="o">=</span> <span class="n">observation_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;observation&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">observation_keys</span>

    <span class="nd">@observation_keys</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">observation_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_observation_keys</span> <span class="o">=</span> <span class="n">_make_list_of_nestedkeys</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;observation_keys&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">excluded_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_keys</span>

    <span class="nd">@excluded_keys</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">excluded_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_excluded_keys</span> <span class="o">=</span> <span class="n">_make_list_of_nestedkeys</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;excluded_keys&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MCTSForest.get_keys_from_env"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.MCTSForest.html#torchrl.data.MCTSForest.get_keys_from_env">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_keys_from_env</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">env</span><span class="p">:</span> <span class="n">EnvBase</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes missing done, action and reward keys to the Forest given an environment.</span>

<span class="sd">        Existing keys are not overwritten.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_reward_keys&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reward_keys</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">reward_keys</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_done_keys&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">done_keys</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">done_keys</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_action_keys&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">action_keys</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">action_keys</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_observation_keys&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">observation_keys</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">observation_keys</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_write_fn_stack</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># This function updates the old values by adding the new ones</span>
        <span class="c1"># if and only if the new ones are not there.</span>
        <span class="c1"># If the old value is not provided, we assume there are none and the</span>
        <span class="c1"># `new` is just prepared.</span>
        <span class="c1"># This involves unsqueezing the last dim (since we&#39;ll be stacking tensors</span>
        <span class="c1"># and calling unique).</span>
        <span class="c1"># The update involves calling cat along the last dim + unique</span>
        <span class="c1"># which will keep only the new values that were unknown to</span>
        <span class="c1"># the storage.</span>
        <span class="c1"># We use this method to track all the indices that are associated with</span>
        <span class="c1"># an observation. Every time a new index is obtained, it is stacked alongside</span>
        <span class="c1"># the others.</span>
        <span class="k">if</span> <span class="n">old</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we unsqueeze the values to stack them along dim -1</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">filter_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">cat</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;count&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">x</span>
                <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># Breaks on mps</span>
                <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;mps&quot;</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;mps&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">old</span><span class="o">.</span><span class="n">named_apply</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">set_</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">old</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_data_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_map</span> <span class="o">=</span> <span class="n">TensorDictMap</span><span class="o">.</span><span class="n">from_tensordict_pair</span><span class="p">(</span>
                <span class="n">source</span><span class="p">,</span>
                <span class="n">dest</span><span class="p">,</span>
                <span class="n">in_keys</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">observation_keys</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">action_keys</span><span class="p">],</span>
                <span class="n">consolidated</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">consolidated</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_map</span><span class="o">.</span><span class="n">max_size</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;A KeyError occurred during data map creation. This could be due to the wrong setting of a key in the MCTSForest constructor. Scroll up for more info.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">err</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_node_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span> <span class="o">=</span> <span class="n">TensorDictMap</span><span class="o">.</span><span class="n">from_tensordict_pair</span><span class="p">(</span>
            <span class="n">source</span><span class="p">,</span>
            <span class="n">dest</span><span class="p">,</span>
            <span class="n">in_keys</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">observation_keys</span><span class="p">],</span>
            <span class="n">out_keys</span><span class="o">=</span><span class="p">[</span>
                <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data_map</span><span class="o">.</span><span class="n">query_module</span><span class="o">.</span><span class="n">out_keys</span><span class="p">,</span>  <span class="c1"># hash and index</span>
                <span class="c1"># *self.action_keys,</span>
                <span class="c1"># *[(&quot;next&quot;, rk) for rk in self.reward_keys],</span>
                <span class="s2">&quot;count&quot;</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">storage_constructor</span><span class="o">=</span><span class="n">ListStorage</span><span class="p">,</span>
            <span class="n">collate_fn</span><span class="o">=</span><span class="n">TensorDict</span><span class="o">.</span><span class="n">lazy_stack</span><span class="p">,</span>
            <span class="n">write_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_fn_stack</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_map</span><span class="o">.</span><span class="n">max_size</span>

<div class="viewcode-block" id="MCTSForest.extend"><a class="viewcode-back" href="../../../../reference/generated/torchrl.data.MCTSForest.html#torchrl.data.MCTSForest.extend">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rollout</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_node</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a rollout to the forest.</span>

<span class="sd">        Nodes are only added to a tree at points where rollouts diverge from</span>
<span class="sd">        each other and at the endpoints of rollouts.</span>

<span class="sd">        If there is no existing tree that matches the first steps of the</span>
<span class="sd">        rollout, a new tree is added. Only one node is created, for the final</span>
<span class="sd">        step.</span>

<span class="sd">        If there is an existing tree that matches, the rollout is added to that</span>
<span class="sd">        tree. If the rollout diverges from all other rollouts in the tree at</span>
<span class="sd">        some step, a new node is created before the step where the rollouts</span>
<span class="sd">        diverge, and a leaf node is created for the final step of the rollout.</span>
<span class="sd">        If all of the rollout&#39;s steps match with a previously added rollout,</span>
<span class="sd">        nothing changes.  If the rollout matches up to a leaf node of a tree but</span>
<span class="sd">        continues beyond it, that node is extended to the end of the rollout,</span>
<span class="sd">        and no new nodes are created.</span>

<span class="sd">        Args:</span>
<span class="sd">            rollout (TensorDict): The rollout to add to the forest.</span>
<span class="sd">            return_node (bool, optional): If ``True``, the method returns the</span>
<span class="sd">                added node. Default is ``False``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tree: The node that was added to the forest. This is only</span>
<span class="sd">                returned if ``return_node`` is True.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; from torchrl.data import MCTSForest</span>
<span class="sd">            &gt;&gt;&gt; from tensordict import TensorDict</span>
<span class="sd">            &gt;&gt;&gt; import torch</span>
<span class="sd">            &gt;&gt;&gt; forest = MCTSForest()</span>
<span class="sd">            &gt;&gt;&gt; r0 = TensorDict({</span>
<span class="sd">            ...     &#39;action&#39;: torch.tensor([1, 2, 3, 4, 5]),</span>
<span class="sd">            ...     &#39;next&#39;: {&#39;observation&#39;: torch.tensor([123, 392, 989, 809, 847])},</span>
<span class="sd">            ...     &#39;observation&#39;: torch.tensor([  0, 123, 392, 989, 809])</span>
<span class="sd">            ... }, [5])</span>
<span class="sd">            &gt;&gt;&gt; r1 = TensorDict({</span>
<span class="sd">            ...     &#39;action&#39;: torch.tensor([1, 2, 6, 7]),</span>
<span class="sd">            ...     &#39;next&#39;: {&#39;observation&#39;: torch.tensor([123, 392, 235,  38])},</span>
<span class="sd">            ...     &#39;observation&#39;: torch.tensor([  0, 123, 392, 235])</span>
<span class="sd">            ... }, [4])</span>
<span class="sd">            &gt;&gt;&gt; td_root = r0[0].exclude(&quot;next&quot;)</span>
<span class="sd">            &gt;&gt;&gt; forest.extend(r0)</span>
<span class="sd">            &gt;&gt;&gt; forest.extend(r1)</span>
<span class="sd">            &gt;&gt;&gt; tree = forest.get_tree(td_root)</span>
<span class="sd">            &gt;&gt;&gt; print(tree)</span>
<span class="sd">            Tree(</span>
<span class="sd">                count=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.int32, is_shared=False),</span>
<span class="sd">                index=Tensor(shape=torch.Size([2]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                node_data=TensorDict(</span>
<span class="sd">                    fields={</span>
<span class="sd">                        observation: Tensor(shape=torch.Size([]), device=cpu, dtype=torch.int64, is_shared=False)},</span>
<span class="sd">                    batch_size=torch.Size([]),</span>
<span class="sd">                    device=cpu,</span>
<span class="sd">                    is_shared=False),</span>
<span class="sd">                node_id=NonTensorData(data=0, batch_size=torch.Size([]), device=None),</span>
<span class="sd">                rollout=TensorDict(</span>
<span class="sd">                    fields={</span>
<span class="sd">                        action: Tensor(shape=torch.Size([2]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                        next: TensorDict(</span>
<span class="sd">                            fields={</span>
<span class="sd">                                observation: Tensor(shape=torch.Size([2]), device=cpu, dtype=torch.int64, is_shared=False)},</span>
<span class="sd">                            batch_size=torch.Size([2]),</span>
<span class="sd">                            device=cpu,</span>
<span class="sd">                            is_shared=False),</span>
<span class="sd">                        observation: Tensor(shape=torch.Size([2]), device=cpu, dtype=torch.int64, is_shared=False)},</span>
<span class="sd">                    batch_size=torch.Size([2]),</span>
<span class="sd">                    device=cpu,</span>
<span class="sd">                    is_shared=False),</span>
<span class="sd">                subtree=Tree(</span>
<span class="sd">                    _parent=NonTensorStack(</span>
<span class="sd">                        [&lt;weakref at 0x716eeb78fbf0; to &#39;TensorDict&#39; at 0x...,</span>
<span class="sd">                        batch_size=torch.Size([2]),</span>
<span class="sd">                        device=None),</span>
<span class="sd">                    count=Tensor(shape=torch.Size([2]), device=cpu, dtype=torch.int32, is_shared=False),</span>
<span class="sd">                    hash=NonTensorStack(</span>
<span class="sd">                        [4341220243998689835, 6745467818783115365],</span>
<span class="sd">                        batch_size=torch.Size([2]),</span>
<span class="sd">                        device=None),</span>
<span class="sd">                    node_data=LazyStackedTensorDict(</span>
<span class="sd">                        fields={</span>
<span class="sd">                            observation: Tensor(shape=torch.Size([2]), device=cpu, dtype=torch.int64, is_shared=False)},</span>
<span class="sd">                        exclusive_fields={</span>
<span class="sd">                        },</span>
<span class="sd">                        batch_size=torch.Size([2]),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        is_shared=False,</span>
<span class="sd">                        stack_dim=0),</span>
<span class="sd">                    node_id=NonTensorStack(</span>
<span class="sd">                        [1, 2],</span>
<span class="sd">                        batch_size=torch.Size([2]),</span>
<span class="sd">                        device=None),</span>
<span class="sd">                    rollout=LazyStackedTensorDict(</span>
<span class="sd">                        fields={</span>
<span class="sd">                            action: Tensor(shape=torch.Size([2, -1]), device=cpu, dtype=torch.int64, is_shared=False),</span>
<span class="sd">                            next: LazyStackedTensorDict(</span>
<span class="sd">                                fields={</span>
<span class="sd">                                    observation: Tensor(shape=torch.Size([2, -1]), device=cpu, dtype=torch.int64, is_shared=False)},</span>
<span class="sd">                                exclusive_fields={</span>
<span class="sd">                                },</span>
<span class="sd">                                batch_size=torch.Size([2, -1]),</span>
<span class="sd">                                device=cpu,</span>
<span class="sd">                                is_shared=False,</span>
<span class="sd">                                stack_dim=0),</span>
<span class="sd">                            observation: Tensor(shape=torch.Size([2, -1]), device=cpu, dtype=torch.int64, is_shared=False)},</span>
<span class="sd">                        exclusive_fields={</span>
<span class="sd">                        },</span>
<span class="sd">                        batch_size=torch.Size([2, -1]),</span>
<span class="sd">                        device=cpu,</span>
<span class="sd">                        is_shared=False,</span>
<span class="sd">                        stack_dim=0),</span>
<span class="sd">                    wins=Tensor(shape=torch.Size([2]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                    index=None,</span>
<span class="sd">                    subtree=None,</span>
<span class="sd">                    specs=None,</span>
<span class="sd">                    batch_size=torch.Size([2]),</span>
<span class="sd">                    device=None,</span>
<span class="sd">                    is_shared=False),</span>
<span class="sd">                wins=Tensor(shape=torch.Size([]), device=cpu, dtype=torch.float32, is_shared=False),</span>
<span class="sd">                hash=None,</span>
<span class="sd">                _parent=None,</span>
<span class="sd">                specs=None,</span>
<span class="sd">                batch_size=torch.Size([]),</span>
<span class="sd">                device=None,</span>
<span class="sd">                is_shared=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">rollout</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">rollout</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">action_keys</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">excluded_keys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">dest</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">excluded_keys</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">dest</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">excluded_keys</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_data_map</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

        <span class="c1"># We need to set the action somewhere to keep track of what action lead to what child</span>
        <span class="c1"># # Set the action in the &#39;next&#39;</span>
        <span class="c1"># dest[1:] = source[:-1].exclude(*self.done_keys)</span>

        <span class="c1"># Add (&#39;observation&#39;, &#39;action&#39;) -&gt; (&#39;next, observation&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_map</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">dest</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_map</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="c1"># map (&#39;observation&#39;,) -&gt; (&#39;indices&#39;,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">TensorDict</span><span class="o">.</span><span class="n">lazy_stack</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">return_node</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tree</span><span class="p">(</span><span class="n">rollout</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_node</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">source</span><span class="p">,</span> <span class="n">dest</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">step</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">step</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">action_keys</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_data_map</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

        <span class="c1"># We need to set the action somewhere to keep track of what action lead to what child</span>
        <span class="c1"># # Set the action in the &#39;next&#39;</span>
        <span class="c1"># dest[1:] = source[:-1].exclude(*self.done_keys)</span>

        <span class="c1"># Add (&#39;observation&#39;, &#39;action&#39;) -&gt; (&#39;next, observation&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_map</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">dest</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_node_map</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="c1"># map (&#39;observation&#39;,) -&gt; (&#39;indices&#39;,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">return_node</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tree</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TensorDictBase</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_map</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_local_tree</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">root</span><span class="p">:</span> <span class="n">TensorDictBase</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tree</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="o">.</span><span class="n">in_keys</span><span class="p">)</span>
        <span class="n">node_meta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="p">:</span>
            <span class="n">node_meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">node_meta</span><span class="p">[</span><span class="s2">&quot;_index&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">index</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_map</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

            <span class="c1"># Rebuild rollout step</span>
            <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merge_tensordicts</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">callback_exist</span><span class="o">=</span><span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="kc">None</span><span class="p">))</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="o">.</span><span class="n">in_keys</span><span class="p">)</span>
                <span class="n">node_meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">node_meta</span><span class="p">[</span><span class="s2">&quot;_index&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">compact</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the root is provided and not gathered from the storage, it could be that its</span>
                <span class="c1"># device doesn&#39;t match the data_map storage device.</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;next&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="o">.</span><span class="n">in_keys</span><span class="p">)</span>
                <span class="n">device</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_map</span><span class="o">.</span><span class="n">storage</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="n">device</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_map</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">root</span><span class="o">.</span><span class="n">clear_device_</span><span class="p">()</span>
                <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">break</span>
        <span class="n">rollout</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">steps</span><span class="p">:</span>
            <span class="n">rollout</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Will be populated later</span>
        <span class="nb">hash</span> <span class="o">=</span> <span class="n">node_meta</span><span class="p">[</span><span class="s2">&quot;_hash&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">Tree</span><span class="p">(</span>
                <span class="n">rollout</span><span class="o">=</span><span class="n">rollout</span><span class="p">,</span>
                <span class="n">count</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">wins</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(()),</span>
                <span class="n">node_data</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="nb">hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="c1"># We do this to avoid raising an exception as rollout and subtree must be provided together</span>
                <span class="n">subtree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="nb">hash</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># The recursive implementation is slower and less compatible with compile</span>
    <span class="c1"># def _make_tree(self, root: TensorDictBase, index: torch.Tensor|None=None)-&gt;Tree:</span>
    <span class="c1">#     tree, indices = self._make_local_tree(root, index=index)</span>
    <span class="c1">#     subtrees = []</span>
    <span class="c1">#     if indices is not None:</span>
    <span class="c1">#         for i in indices:</span>
    <span class="c1">#             subtree = self._make_tree(tree.node, index=i)</span>
    <span class="c1">#             subtrees.append(subtree)</span>
    <span class="c1">#         subtrees = TensorDict.lazy_stack(subtrees)</span>
    <span class="c1">#         tree.subtree = subtrees</span>
    <span class="c1">#     return tree</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_make_tree_iter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">compact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tree</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="nb">hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_local_tree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">node_id</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tree</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">tree</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">extend</span> <span class="o">=</span> <span class="n">max_depth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">max_depth</span>
            <span class="n">subtrees</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">hash</span><span class="p">):</span>
                <span class="c1"># TODO: remove the .item()</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="n">subtree</span><span class="p">,</span> <span class="n">subtree_indices</span><span class="p">,</span> <span class="n">subtree_hash</span> <span class="o">=</span> <span class="n">memo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">subtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">subtree</span><span class="p">,</span> <span class="n">subtree_indices</span><span class="p">,</span> <span class="n">subtree_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_local_tree</span><span class="p">(</span>
                        <span class="n">tree</span><span class="o">.</span><span class="n">node_data</span><span class="p">,</span>
                        <span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                        <span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">subtree</span><span class="o">.</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">counter</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">subtree</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">h</span>
                    <span class="n">memo</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">subtree</span><span class="p">,</span> <span class="n">subtree_indices</span><span class="p">,</span> <span class="n">subtree_hash</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># We just need to save the two (or more) rollouts</span>
                    <span class="n">subtree_bis</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_local_tree</span><span class="p">(</span>
                        <span class="n">tree</span><span class="o">.</span><span class="n">node_data</span><span class="p">,</span>
                        <span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                        <span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">subtree</span><span class="o">.</span><span class="n">rollout</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">subtree_bis</span><span class="o">.</span><span class="n">rollout</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                        <span class="n">subtree</span><span class="o">.</span><span class="n">rollout</span> <span class="o">=</span> <span class="n">TensorDict</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">subtree</span><span class="o">.</span><span class="n">rollout</span><span class="p">,</span> <span class="n">subtree_bis</span><span class="o">.</span><span class="n">rollout</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">subtree</span><span class="o">.</span><span class="n">rollout</span> <span class="o">=</span> <span class="n">TensorDict</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                            <span class="p">[</span><span class="o">*</span><span class="n">subtree</span><span class="o">.</span><span class="n">rollout</span><span class="p">,</span> <span class="n">subtree_bis</span><span class="o">.</span><span class="n">rollout</span><span class="p">]</span>
                        <span class="p">)</span>

                <span class="n">subtrees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">extend</span> <span class="ow">and</span> <span class="n">subtree_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">subtree</span><span class="p">,</span> <span class="n">subtree_indices</span><span class="p">,</span> <span class="n">subtree_hash</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">subtrees</span> <span class="o">=</span> <span class="n">TensorDict</span><span class="o">.</span><span class="n">lazy_stack</span><span class="p">(</span><span class="n">subtrees</span><span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">subtree</span> <span class="o">=</span> <span class="n">subtrees</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_tree</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">root</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">max_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tree</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_tree_iter</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="n">max_depth</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">valid_paths</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">Tree</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="n">tree</span><span class="o">.</span><span class="n">valid_paths</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_map</span><span class="p">)</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_make_list_of_nestedkeys</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">NestedKey</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> must be a list of NestedKeys or a NestedKey, got </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">unravel_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
</pre></div>

             </article>
             
            </div>
            <footer>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, Meta.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>


        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              
            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
         <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
         <script src="../../../../_static/jquery.js"></script>
         <script src="../../../../_static/underscore.js"></script>
         <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
         <script src="../../../../_static/doctools.js"></script>
         <script src="../../../../_static/design-tabs.js"></script>
     

  

  <script type="text/javascript" src="../../../../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
     
    <script type="text/javascript">
      $(document).ready(function() {
	  var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
	  if (downloadNote.length >= 1) {
	      var tutorialUrl = $("#tutorial-type").text();
	      var githubLink = "https://github.com/pytorch/rl/blob/main/tutorials/sphinx-tutorials/"  + tutorialUrl + ".py",
		  notebookLink = $(".sphx-glr-download-jupyter").find(".download.reference")[0].href,
		  notebookDownloadPath = notebookLink.split('_downloads')[1],
		  colabLink = "https://colab.research.google.com/github/pytorch/rl/blob/gh-pages/main/_downloads" + notebookDownloadPath;

	      $(".pytorch-call-to-action-links a[data-response='Run in Google Colab']").attr("href", colabLink);
	      $(".pytorch-call-to-action-links a[data-response='View on Github']").attr("href", githubLink);
	  }

          var overwrite = function(_) {
              if ($(this).length > 0) {
                  $(this)[0].href = "https://github.com/pytorch/rl"
              }
          }
          // PC
          $(".main-menu a:contains('GitHub')").each(overwrite);
          // Mobile
          $(".main-menu a:contains('Github')").each(overwrite);
      });

      
       $(window).ready(function() {
           var original = window.sideMenus.bind;
           var startup = true;
           window.sideMenus.bind = function() {
               original();
               if (startup) {
                   $("#pytorch-right-menu a.reference.internal").each(function(i) {
                       if (this.classList.contains("not-expanded")) {
                           this.nextElementSibling.style.display = "block";
                           this.classList.remove("not-expanded");
                           this.classList.add("expanded");
                       }
                   });
                   startup = false;
               }
           };
       });
    </script>

    


  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-4 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer documentation for PyTorch</p>
          <a class="with-right-arrow" href="https://pytorch.org/docs/stable/index.html">View Docs</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Tutorials</h2>
          <p>Get in-depth tutorials for beginners and advanced developers</p>
          <a class="with-right-arrow" href="https://pytorch.org/tutorials">View Tutorials</a>
        </div>

        <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="https://pytorch.org/resources">View Resources</a>
        </div>
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://pytorch.org/" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/">PyTorch</a></li>
            <li><a href="https://pytorch.org/get-started">Get Started</a></li>
            <li><a href="https://pytorch.org/features">Features</a></li>
            <li><a href="https://pytorch.org/ecosystem">Ecosystem</a></li>
            <li><a href="https://pytorch.org/blog/">Blog</a></li>
            <li><a href="https://github.com/pytorch/pytorch/blob/master/CONTRIBUTING.md">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://pytorch.org/resources">Resources</a></li>
            <li><a href="https://pytorch.org/tutorials">Tutorials</a></li>
            <li><a href="https://pytorch.org/docs/stable/index.html">Docs</a></li>
            <li><a href="https://discuss.pytorch.org" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/pytorch/pytorch/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://pytorch.org/assets/brand-guidelines/PyTorch-Brand-Guidelines.pdf" target="_blank">Brand Guidelines</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">Stay up to date</li>
            <li><a href="https://www.facebook.com/pytorch" target="_blank">Facebook</a></li>
            <li><a href="https://twitter.com/pytorch" target="_blank">Twitter</a></li>
            <li><a href="https://www.youtube.com/pytorch" target="_blank">YouTube</a></li>
            <li><a href="https://www.linkedin.com/company/pytorch" target="_blank">LinkedIn</a></li>
          </ul>  
          </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title">PyTorch Podcasts</li>
            <li><a href="https://open.spotify.com/show/6UzHKeiy368jKfQMKKvJY5" target="_blank">Spotify</a></li>
            <li><a href="https://podcasts.apple.com/us/podcast/pytorch-developer-podcast/id1566080008" target="_blank">Apple</a></li>
            <li><a href="https://www.google.com/podcasts?feed=aHR0cHM6Ly9mZWVkcy5zaW1wbGVjYXN0LmNvbS9PQjVGa0lsOA%3D%3D" target="_blank">Google</a></li>
            <li><a href="https://music.amazon.com/podcasts/7a4e6f0e-26c2-49e9-a478-41bd244197d0/PyTorch-Developer-Podcast?" target="_blank">Amazon</a></li>
          </ul>
         </div>
        </div>
        
        <div class="privacy-policy">
          <ul>
            <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/terms/" target="_blank">Terms</a></li>
            <li class="privacy-policy-links">|</li>
            <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/privacy-policy/" target="_blank">Privacy</a></li>
          </ul>
        </div>
        <div class="copyright">
        <p>Â© Copyright The Linux Foundation. The PyTorch Foundation is a project of The Linux Foundation.
          For web site terms of use, trademark policy and other policies applicable to The PyTorch Foundation please see
          <a href="https://www.linuxfoundation.org/policies/">www.linuxfoundation.org/policies/</a>. The PyTorch Foundation supports the PyTorch open source
          project, which has been established as PyTorch Project a Series of LF Projects, LLC. For policies applicable to the PyTorch Project a Series of LF Projects, LLC,
          please see <a href="https://www.lfprojects.org/policies/">www.lfprojects.org/policies/</a>.</p>
      </div>
     </div>

  </footer>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebookâ€™s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../../../../_static/images/pytorch-x.svg">
  </div>
</div>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
           <li class="resources-mobile-menu-title">
             <a>Learn</a>
           </li>
           <ul class="resources-mobile-menu-items">
             <li>
               <a href="https://pytorch.org/get-started">Get Started</a>
             </li>
             <li>
               <a href="https://pytorch.org/tutorials">Tutorials</a>
             </li>
             <li>
               <a href="https://pytorch.org/tutorials/beginner/basics/intro.html">Learn the Basics</a>
             </li>
             <li>
               <a href="https://pytorch.org/tutorials/recipes/recipes_index.html">PyTorch Recipes</a>
             </li>
             <li>
               <a href="https://pytorch.org/tutorials/beginner/introyt.html">Introduction to PyTorch - YouTube Series</a>
             </li>
           </ul>
           <li class="resources-mobile-menu-title">
             <a>Ecosystem</a>
           </li>
           <ul class="resources-mobile-menu-items">
             <li>
               <a href="https://pytorch.org/ecosystem">Tools</a>
             </li>
             <li>
               <a href="https://pytorch.org/#community-module">Community</a>
             </li>
             <li>
               <a href="https://discuss.pytorch.org/">Forums</a>
             </li>
             <li>
               <a href="https://pytorch.org/resources">Developer Resources</a>
             </li>
             <li>
               <a href="https://pytorch.org/ecosystem/contributor-awards-2023">Contributor Awards - 2024</a>
             </li>
           </ul>

           <li class="resources-mobile-menu-title">
             <a>Edge</a>
           </li>

           <ul class="resources-mobile-menu-items">
             <li>
               <a href="https://pytorch.org/edge">About PyTorch Edge</a>
             </li>
             
             <li>
               <a href="https://pytorch.org/executorch-overview">ExecuTorch</a>
             </li>
             <li>
               <a href="https://pytorch.org/executorch/stable/index.html">ExecuTorch Documentation</a>
             </li>
           </ul>

           <li class="resources-mobile-menu-title">
             <a>Docs</a>
           </li>

           <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/docs/stable/index.html">PyTorch</a>
            </li>

            <li>
              <a href="https://pytorch.org/pytorch-domains">PyTorch Domains</a>
            </li>
          </ul>

          <li class="resources-mobile-menu-title">
            <a>Blog & News</a>
          </li>
            
           <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/blog/">PyTorch Blog</a>
            </li>
            <li>
              <a href="https://pytorch.org/community-blog">Community Blog</a>
            </li>

            <li>
              <a href="https://pytorch.org/videos">Videos</a>
            </li>

            <li>
              <a href="https://pytorch.org/community-stories">Community Stories</a>
            </li>
            <li>
              <a href="https://pytorch.org/events">Events</a>
            </li>
            <li>
               <a href="https://pytorch.org/newsletter">Newsletter</a>
             </li>
          </ul>
          
          <li class="resources-mobile-menu-title">
            <a>About</a>
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://pytorch.org/foundation">PyTorch Foundation</a>
            </li>
            <li>
              <a href="https://pytorch.org/governing-board">Governing Board</a>
            </li>
            <li>
               <a href="https://pytorch.org/credits">Cloud Credit Program</a>
            </li>
            <li>
               <a href="https://pytorch.org/tac">Technical Advisory Council</a>
            </li>
            <li>
               <a href="https://pytorch.org/staff">Staff</a>
            </li>
            <li>
               <a href="https://pytorch.org/contact-us">Contact Us</a>
            </li>
          </ul>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../../../../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>