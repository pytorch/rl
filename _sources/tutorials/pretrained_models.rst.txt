
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/pretrained_models.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_pretrained_models.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_pretrained_models.py:


Using pretrained models
=======================
This tutorial explains how to use pretrained models in TorchRL.

.. GENERATED FROM PYTHON SOURCE LINES 8-16

At the end of this tutorial, you will be capable of using pretrained models
for efficient image representation, and fine-tune them.

TorchRL provides pretrained models that are to be used either as transforms or as
components of the policy. As the sematic is the same, they can be used interchangeably
in one or the other context. In this tutorial, we will be using R3M (https://arxiv.org/abs/2203.12601),
but other models (e.g. VIP) will work equally well.


.. GENERATED FROM PYTHON SOURCE LINES 16-32

.. code-block:: Python



    import torch.cuda
    from tensordict.nn import TensorDictSequential
    from torch import nn
    from torchrl.envs import R3MTransform, TransformedEnv
    from torchrl.envs.libs.gym import GymEnv
    from torchrl.modules import Actor

    is_fork = multiprocessing.get_start_method() == "fork"
    device = (
        torch.device(0)
        if torch.cuda.is_available() and not is_fork
        else torch.device("cpu")
    )








.. GENERATED FROM PYTHON SOURCE LINES 53-57

Let us first create an environment. For the sake of simplicity, we will be using
a common gym environment. In practice, this will work in more challenging, embodied
AI contexts (e.g. have a look at our Habitat wrappers).


.. GENERATED FROM PYTHON SOURCE LINES 57-59

.. code-block:: Python

    base_env = GymEnv("Ant-v4", from_pixels=True, device=device)








.. GENERATED FROM PYTHON SOURCE LINES 60-67

Let us fetch our pretrained model. We ask for the pretrained version of the model through the
download=True flag. By default this is turned off.
Next, we will append our transform to the environment. In practice, what will happen is that
each batch of data collected will go through the transform and be mapped on a "r3m_vec" entry
in the output tensordict. Our policy, consisting of a single layer MLP, will then read this vector and compute
the corresponding action.


.. GENERATED FROM PYTHON SOURCE LINES 67-80

.. code-block:: Python

    r3m = R3MTransform(
        "resnet50",
        in_keys=["pixels"],
        download=True,
    )
    env_transformed = TransformedEnv(base_env, r3m)
    net = nn.Sequential(
        nn.LazyLinear(128, device=device),
        nn.Tanh(),
        nn.Linear(128, base_env.action_spec.shape[-1], device=device),
    )
    policy = Actor(net, in_keys=["r3m_vec"])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Downloading: "https://pytorch.s3.amazonaws.com/models/rl/r3m/r3m_50.pt" to /root/.cache/torch/hub/checkpoints/r3m_50.pt
      0%|          | 0.00/374M [00:00<?, ?B/s]      4%|▍         | 16.5M/374M [00:00<00:03, 108MB/s]      9%|▉         | 32.9M/374M [00:00<00:03, 119MB/s]     13%|█▎        | 49.2M/374M [00:00<00:03, 102MB/s]     18%|█▊        | 65.6M/374M [00:00<00:03, 106MB/s]     22%|██▏       | 82.0M/374M [00:00<00:02, 107MB/s]     26%|██▋       | 98.4M/374M [00:00<00:02, 101MB/s]     31%|███       | 115M/374M [00:01<00:02, 98.2MB/s]     35%|███▌      | 131M/374M [00:01<00:02, 97.0MB/s]     39%|███▉      | 148M/374M [00:01<00:02, 108MB/s]      44%|████▎     | 163M/374M [00:01<00:01, 120MB/s]     47%|████▋     | 176M/374M [00:01<00:01, 114MB/s]     50%|█████     | 187M/374M [00:01<00:01, 103MB/s]     53%|█████▎    | 198M/374M [00:02<00:02, 72.9MB/s]     57%|█████▋    | 212M/374M [00:02<00:02, 78.9MB/s]     59%|█████▉    | 221M/374M [00:02<00:02, 79.7MB/s]     61%|██████▏   | 229M/374M [00:02<00:02, 74.6MB/s]     66%|██████▌   | 246M/374M [00:02<00:01, 91.7MB/s]     70%|███████   | 262M/374M [00:02<00:01, 99.8MB/s]     74%|███████▍  | 277M/374M [00:02<00:00, 109MB/s]      77%|███████▋  | 288M/374M [00:03<00:00, 107MB/s]     80%|███████▉  | 298M/374M [00:03<00:00, 86.7MB/s]     83%|████████▎ | 311M/374M [00:03<00:00, 75.8MB/s]     88%|████████▊ | 328M/374M [00:03<00:00, 87.9MB/s]     92%|█████████▏| 342M/374M [00:03<00:00, 90.7MB/s]     94%|█████████▍| 352M/374M [00:03<00:00, 84.8MB/s]     96%|█████████▋| 360M/374M [00:04<00:00, 68.3MB/s]    100%|██████████| 374M/374M [00:04<00:00, 93.7MB/s]




.. GENERATED FROM PYTHON SOURCE LINES 81-83

Let's check the number of parameters of the policy:


.. GENERATED FROM PYTHON SOURCE LINES 83-85

.. code-block:: Python

    print("number of params:", len(list(policy.parameters())))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of params: 4




.. GENERATED FROM PYTHON SOURCE LINES 86-88

We collect a rollout of 32 steps and print its output:


.. GENERATED FROM PYTHON SOURCE LINES 88-91

.. code-block:: Python

    rollout = env_transformed.rollout(32, policy)
    print("rollout with transform:", rollout)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    rollout with transform: TensorDict(
        fields={
            action: Tensor(shape=torch.Size([32, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
                    reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False),
                    terminated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    truncated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False)},
                batch_size=torch.Size([32]),
                device=cpu,
                is_shared=False),
            r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
            terminated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            truncated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False)},
        batch_size=torch.Size([32]),
        device=cpu,
        is_shared=False)




.. GENERATED FROM PYTHON SOURCE LINES 92-96

For fine tuning, we integrate the transform in the policy after making the parameters
trainable. In practice, it may be wiser to restrict this to a subset of the parameters (say the last layer
of the MLP).


.. GENERATED FROM PYTHON SOURCE LINES 96-100

.. code-block:: Python

    r3m.train()
    policy = TensorDictSequential(r3m, policy)
    print("number of params after r3m is integrated:", len(list(policy.parameters())))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    number of params after r3m is integrated: 163




.. GENERATED FROM PYTHON SOURCE LINES 101-105

Again, we collect a rollout with R3M. The structure of the output has changed slightly, as now
the environment returns pixels (and not an embedding). The embedding "r3m_vec" is an intermediate
result of our policy.


.. GENERATED FROM PYTHON SOURCE LINES 105-108

.. code-block:: Python

    rollout = base_env.rollout(32, policy)
    print("rollout, fine tuning:", rollout)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    rollout, fine tuning: TensorDict(
        fields={
            action: Tensor(shape=torch.Size([32, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    pixels: Tensor(shape=torch.Size([32, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False),
                    reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False),
                    terminated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    truncated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False)},
                batch_size=torch.Size([32]),
                device=cpu,
                is_shared=False),
            r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
            terminated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            truncated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False)},
        batch_size=torch.Size([32]),
        device=cpu,
        is_shared=False)




.. GENERATED FROM PYTHON SOURCE LINES 109-116

The easiness with which we have swapped the transform from the env to the policy
is due to the fact that both behave like TensorDictModule: they have a set of `"in_keys"` and
`"out_keys"` that make it easy to read and write output in different context.

To conclude this tutorial, let's have a look at how we could use R3M to read
images stored in a replay buffer (e.g. in an offline RL context). First, let's build our dataset:


.. GENERATED FROM PYTHON SOURCE LINES 116-121

.. code-block:: Python

    from torchrl.data import LazyMemmapStorage, ReplayBuffer

    storage = LazyMemmapStorage(1000)
    rb = ReplayBuffer(storage=storage, transform=r3m)








.. GENERATED FROM PYTHON SOURCE LINES 122-125

We can now collect the data (random rollouts for our purpose) and fill the replay
buffer with it:


.. GENERATED FROM PYTHON SOURCE LINES 125-131

.. code-block:: Python

    total = 0
    while total < 1000:
        tensordict = base_env.rollout(1000)
        rb.extend(tensordict)
        total += tensordict.numel()








.. GENERATED FROM PYTHON SOURCE LINES 132-134

Let's check what our replay buffer storage looks like. It should not contain the "r3m_vec" entry
since we haven't used it yet:

.. GENERATED FROM PYTHON SOURCE LINES 134-136

.. code-block:: Python

    print("stored data:", storage._storage)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    stored data: TensorDict(
        fields={
            action: MemoryMappedTensor(shape=torch.Size([1000, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: MemoryMappedTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    done: MemoryMappedTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    pixels: MemoryMappedTensor(shape=torch.Size([1000, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False),
                    reward: MemoryMappedTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.float32, is_shared=False),
                    terminated: MemoryMappedTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    truncated: MemoryMappedTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.bool, is_shared=False)},
                batch_size=torch.Size([1000]),
                device=cpu,
                is_shared=False),
            pixels: MemoryMappedTensor(shape=torch.Size([1000, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False),
            terminated: MemoryMappedTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            truncated: MemoryMappedTensor(shape=torch.Size([1000, 1]), device=cpu, dtype=torch.bool, is_shared=False)},
        batch_size=torch.Size([1000]),
        device=cpu,
        is_shared=False)




.. GENERATED FROM PYTHON SOURCE LINES 137-140

When sampling, the data will go through the R3M transform, giving us the processed data that we wanted.
In this way, we can train an algorithm offline on a dataset made of images:


.. GENERATED FROM PYTHON SOURCE LINES 140-143

.. code-block:: Python

    batch = rb.sample(32)
    print("data after sampling:", batch)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    data after sampling: TensorDict(
        fields={
            action: Tensor(shape=torch.Size([32, 8]), device=cpu, dtype=torch.float32, is_shared=False),
            done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            next: TensorDict(
                fields={
                    done: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    pixels: Tensor(shape=torch.Size([32, 480, 480, 3]), device=cpu, dtype=torch.uint8, is_shared=False),
                    reward: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.float32, is_shared=False),
                    terminated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
                    truncated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False)},
                batch_size=torch.Size([32]),
                device=cpu,
                is_shared=False),
            r3m_vec: Tensor(shape=torch.Size([32, 2048]), device=cpu, dtype=torch.float32, is_shared=False),
            terminated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False),
            truncated: Tensor(shape=torch.Size([32, 1]), device=cpu, dtype=torch.bool, is_shared=False)},
        batch_size=torch.Size([32]),
        device=cpu,
        is_shared=False)





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 50.400 seconds)

**Estimated memory usage:**  3582 MB


.. _sphx_glr_download_tutorials_pretrained_models.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: pretrained_models.ipynb <pretrained_models.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: pretrained_models.py <pretrained_models.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
